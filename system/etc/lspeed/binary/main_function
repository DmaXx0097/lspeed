#!/system/bin/sh
# L Speed tweak
# Codename : lspeed
version="v1.6.4-b3";
build_date=20-1-2020;
# Developer : Paget96
# Paypal : https://paypal.me/Paget96

# To select current profile go to /data/lspeed/setup
# and edit file "profile"
# 0 - default
# 1 - power saving
# 2 - balanced
# 3 - performance
# Save the file and reboot phone
#
# To check if mod working go to /data/lspeed/log/main_log.log
# that's main output after executing lspeed.sh
#

########
#PATHS #
########
# Path where logs and setup is stored
LSPEED_DATA_DIR=/data/lspeed
LOG_DIR=$LSPEED_DATA_DIR/log
LOG=$LOG_DIR/main_log.log

# Setup paths
SETUP_DIR=$LSPEED_DATA_DIR/setup
USER_PROFILE=$SETUP_DIR/user_profile
PROFILE=$SETUP_DIR/profile
IS_EXECUTED=$LSPEED_DATA_DIR/is_executed

# Path for executables and busybox
LSPEED=/system/etc/lspeed
BINARY_DIR=$LSPEED/binary
BUSYBOX=$BINARY_DIR/busybox
CPU_DETECT=$BINARY_DIR/cpu_detect
CPUSET_TUNER=$BINARY_DIR/cpuset_tuner

# cpu_detect output files
CPU_DETECT_DATA_DIR=$SETUP_DIR/cpu_detect
CPU_CORE_COUNT=$CPU_DETECT_DATA_DIR/cpu_core_count
REAL_CPU_CORE_COUNT=$CPU_DETECT_DATA_DIR/real_cpu_core_count
MIN_MAX_FREQ=$CPU_DETECT_DATA_DIR/min_max_freq
MIN_FREQ_LIST=$CPU_DETECT_DATA_DIR/min_freq_list
MAX_FREQ_LIST=$CPU_DETECT_DATA_DIR/max_freq_list
LOGICAL_CORE=$CPU_DETECT_DATA_DIR/logical_core
UNIQUE_FREQ=$CPU_DETECT_DATA_DIR/unique_freq
CORE_GETTER=$CPU_DETECT_DATA_DIR/core_getter

# Variables
memTotal=$($BUSYBOX free -m | $BUSYBOX awk '/^Mem:/{print $2}');
# Prevent issues when $memTotal return weird output (including non-integer values, empty strings...),
# in this case device acts like a 4GB RAM device
case $memTotal in
    ''|*[!0-9]*) memTotal=4096 ;;
    *) memTotal=$memTotal ;;
esac

abi=$($BUSYBOX grep /system/build.prop ro.product.cpu.abi | $BUSYBOX head -n1 | $BUSYBOX cut -d= -f2);
case $abi in
    arm*|x86*) ;;
    *) abi=$(getprop ro.product.cpu.abi);;
esac;
case $abi in
    arm*|x86*) ;;
    *) abi=$($BUSYBOX grep /system/default.prop ro.product.cpu.abi | $BUSYBOX head -n1 | $BUSYBOX cut -d= -f2);
esac;
case $abi in
    arm64*) arch=arm64;;
    arm*) arch=arm;;
    x86_64*) arch=x86_64;;
    x86*) arch=x86;;
    *) arch="Unknown arch: $abi";;
esac;

real_cpu_cores=$($BUSYBOX ls /sys/devices/system/cpu | $BUSYBOX grep -c ^cpu[0-9]);
cpu_cores=$((real_cpu_cores-1));
brand=$(getprop ro.product.brand) 2>/dev/null
model=$(getprop ro.product.model) 2>/dev/null
rom=$(getprop ro.build.display.id) 2>/dev/null
androidRelease=$(getprop ro.build.version.release) 2>/dev/null
api=$(getprop ro.build.version.sdk) 2>/dev/null
kernel=$(uname -r) 2>/dev/null
root=$(magisk -c) 2>/dev/null
divider="==============================================="

# Detecting modules path
if [ -d /data/adb/modules ]; then
	MODULES=/data/adb/modules
elif [ -d /sbin/.core/img ]; then
	MODULES=/sbin/.core/img
elif [ -d /sbin/.magisk/img ]; then
	MODULES=/sbin/.magisk/img
fi;

# Functions
createFile() {
    touch "$1"
    chmod 0666 "$1"
}

sendToLog() {
timeZone=$(getprop persist.sys.timezone)
printDate=$(TZ="$timeZone" $BUSYBOX date +"%H:%M:%S:%3N %d-%m-%Y")

echo "[$printDate] $1" >> $LOG
}

write() {
	#chmod 0644 "$1"
    echo "$2" > "$1"
}

lockFile() {
	chmod 0644 "$1"
    echo "$2" > "$1"
	chmod 0444 "$1"
}

getScheduler() {
	echo "$($BUSYBOX cut -d [ -f2 "$1"/queue/scheduler | $BUSYBOX cut -d] -f1)"
}

# Setting up the main path where are logs and setup is stored
# If for any reason any of them are missing, add them manually
if [ ! -d $LSPEED_DATA_DIR ]; then
	mkdir -p $LSPEED_DATA_DIR
fi;

# Create log directory if doesn't exists
# All the logs will be placed here
if [ ! -d $LOG_DIR ]; then
	mkdir -p $LOG_DIR
fi;

# Remove old logs when running the script again
# and create dir if not exists
# This will be only executed if there are no arguments while executing
if [ "$#" -eq 0 ]; then
	if [ -e $LOG ]; then
		rm -rf $LOG
	fi;
fi;

# Create setup dir and child files and dirs
# Needed for module working at all
# /data/lsepeed/setup/profile
# /data/lsepeed/setup/user_profile/*
if [ ! -d $SETUP_DIR ]; then
	mkdir -p $SETUP_DIR
fi;

# Create $PROFILE file if not exists
if [ ! -f $PROFILE ]; then
	createFile $PROFILE
fi;

# Directory dedicated for storing current profile
if [ ! -d $USER_PROFILE ]; then
	mkdir -p $USER_PROFILE
fi;

# Store the PID
write $LSPEED_DATA_DIR/main_function_PID $$

# Create controllers
# This will be used for the Manager to take a control over the module
if [ -d $USER_PROFILE ]; then
	createFile $USER_PROFILE/battery_improvements
	createFile $USER_PROFILE/doze_optimization

	# CPU section
	createFile $USER_PROFILE/cpu_optimization
	createFile $USER_PROFILE/governor_tuner

	createFile $USER_PROFILE/entropy

	# GPU section
	createFile $USER_PROFILE/gpu_optimizer
	createFile $USER_PROFILE/optimize_buffers
	createFile $USER_PROFILE/render_opengles_using_gpu
	createFile $USER_PROFILE/use_opengl_skia
	createFile $USER_PROFILE/force_gpu_rendering
	createFile $USER_PROFILE/force_4x_msaa

	# I/O tweaks section
	createFile $USER_PROFILE/disable_io_stats
	createFile $USER_PROFILE/io_blocks_optimization
	createFile $USER_PROFILE/io_extended_queue
	createFile $USER_PROFILE/scheduler_tuner

	# LNET tweaks section
	createFile $USER_PROFILE/dns
	createFile $USER_PROFILE/net_buffers
	createFile $USER_PROFILE/net_speed_plus
	createFile $USER_PROFILE/net_tcp
	createFile $USER_PROFILE/optimize_ril

	# Other
	createFile $USER_PROFILE/disable_debugging
	createFile $USER_PROFILE/disable_kernel_panic
	createFile $USER_PROFILE/selinux

	# RAM manager section
	createFile $USER_PROFILE/ram_manager
	createFile $USER_PROFILE/disable_multitasking_limitations
	createFile $USER_PROFILE/low_ram_flag
	createFile $USER_PROFILE/oom_killer
	createFile $USER_PROFILE/swappiness
	createFile $USER_PROFILE/virtual_memory
	createFile $USER_PROFILE/heap_optimization

fi;

# Get device info when starting the module. 
# this will be done only on boot or executed service with sh over terminal
if [ "$#" -eq 0 ] || [ ! -e $LOG ]; then
	sendToLog "L Speed finished with base setup";
	write $IS_EXECUTED "true"
	
	sendToLog "Starting with logging...";
	sendToLog $divider;
	sendToLog "Getting module info"
	sendToLog "Version: $version ($build_date)";
	sendToLog $divider;
	sendToLog "Getting device info"
	sendToLog "Brand: $brand"
	sendToLog "Model: $model"
	sendToLog "Arch: $arch"
	sendToLog "ROM: $rom (Android: $androidRelease|API: $api)"
	sendToLog "Kernel: $kernel"
	sendToLog "Root: $root"
	sendToLog "RAM: $((memTotal))mb"
	sendToLog $divider;
fi

#
# Battery improvements
#
batteryImprovements() {
sendToLog "Activating battery improvements...";

	# Disabling ksm
	if [ -e "/sys/kernel/mm/ksm/run" ]; then
		write /sys/kernel/mm/ksm/run "0";
		sendToLog "KSM is disabled, saving battery cycles and improving battery life...";
	fi;

	# Disabling uksm
	if [ -e "/sys/kernel/mm/uksm/run" ]; then
		write /sys/kernel/mm/uksm/run "0"
		sendToLog "UKSM is disabled, saving battery cycles and improving battery life...";
	fi;

	# Kernel sleepers
	if [ -e "/sys/kernel/sched/gentle_fair_sleepers" ]; then
		write /sys/kernel/sched/gentle_fair_sleepers "0"
		sendToLog "Gentle fair sleepers disabled...";
	fi;

	if [ -e "/sys/kernel/sched/arch_power" ]; then
		write /sys/kernel/sched/arch_power "1"
		sendToLog "Arch power enabled...";
	fi;

	if [ -e "/sys/kernel/debug/sched_features" ]; then
		# Only give sleepers 50% of their service deficit. This allows
		# them to run sooner, but does not allow tons of sleepers to
		# rip the spread apart.
		write /sys/kernel/debug/sched_features "NO_GENTLE_FAIR_SLEEPERS"
		sendToLog "GENTLE_FAIR_SLEEPERS disabled...";

		write /sys/kernel/debug/sched_features "ARCH_POWER"
		sendToLog "ARCH_POWER enabled...";
	fi;
	
	#/sys/power/pm_freeze_timeout controls how long it will cost at most to freeze
	#all user space processes or all freezable kernel threads, in unit of millisecond.
	#The default value is 20000, some Xiaomi devices are going in range from 2000 to 15000
	#more info on https://www.kernel.org/doc/Documentation/power/freezing-of-tasks.txt
	if [ -e "/sys/power/pm_freeze_timeout" ];  then
		write /sys/power/pm_freeze_timeout "5000"
		sendToLog "Kernel thread freeze time set to 5 seconds";
	fi;

	# Enable fast charging
	if [ -e "/sys/kernel/fast_charge/force_fast_charge" ];  then
		write /sys/kernel/fast_charge/force_fast_charge "1"
		sendToLog "Fast charge enabled";
	fi;

	scsi_disk=$($BUSYBOX ls -d /sys/class/scsi_disk/*) 2>/dev/null
	for i in $scsi_disk; do
 		write "$i"/cache_type "temporary none"
 		sendToLog "Set cache type to temporary none in $i";
 	done

	if [ -e /sys/module/wakeup/parameters/enable_bluetooth_timer ]; then
		write /sys/module/wakeup/parameters/enable_bluetooth_timer "Y"
		write /sys/module/wakeup/parameters/enable_ipa_ws "N"
		write /sys/module/wakeup/parameters/enable_netlink_ws "Y"
		write /sys/module/wakeup/parameters/enable_netmgr_wl_ws "Y"
		write /sys/module/wakeup/parameters/enable_qcom_rx_wakelock_ws "N"
		write /sys/module/wakeup/parameters/enable_timerfd_ws "Y"
		write /sys/module/wakeup/parameters/enable_wlan_extscan_wl_ws "N"
		write /sys/module/wakeup/parameters/enable_wlan_wow_wl_ws "N"
		write /sys/module/wakeup/parameters/enable_wlan_ws "N"
		write /sys/module/wakeup/parameters/enable_netmgr_wl_ws "N"
		write /sys/module/wakeup/parameters/enable_wlan_wow_wl_ws "N"
		write /sys/module/wakeup/parameters/enable_wlan_ipa_ws "N"
		write /sys/module/wakeup/parameters/enable_wlan_pno_wl_ws "N"
		write /sys/module/wakeup/parameters/enable_wcnss_filter_lock_ws "N"
		sendToLog "Blocked various wakelocks";
	fi;

	if [ -e /sys/module/bcmdhd/parameters/wlrx_divide ]; then
		write /sys/module/bcmdhd/parameters/wlrx_divide "4"
		write /sys/module/bcmdhd/parameters/wlctrl_divide "4"
		sendToLog "wlan wakelocks blocked";
	fi;

	if [ -e /sys/devices/virtual/misc/boeffla_wakelock_blocker/wakelock_blocker ]; then
		write /sys/devices/virtual/misc/boeffla_wakelock_blocker/wakelock_blocker "wlan_pno_wl;wlan_ipa;wcnss_filter_lock;hal_bluetooth_lock;IPA_WS;sensor_ind;wlan;netmgr_wl;qcom_rx_wakelock;wlan_wow_wl;wlan_extscan_wl;NETLINK;bam_dmux_wakelock;IPA_RM12"
		sendToLog "Updated Boeffla wakelock blocker";

	elif [ -e /sys/class/misc/boeffla_wakelock_blocker/wakelock_blocker ]; then
		write /sys/class/misc/boeffla_wakelock_blocker/wakelock_blocker "wlan_pno_wl;wlan_ipa;wcnss_filter_lock;hal_bluetooth_lock;IPA_WS;sensor_ind;wlan;netmgr_wl;qcom_rx_wakelock;wlan_wow_wl;wlan_extscan_wl;NETLINK;bam_dmux_wakelock;IPA_RM12"
		sendToLog "Updated Boeffla wakelock blocker";
	fi;

	# lpm Levels
	lpm=/sys/module/lpm_levels
	if [ -d $lpm/parameters ]; then
		write $lpm/parameters/lpm_prediction "Y"
		write $lpm/parameters/sleep_disabled "0"
		sendToLog "Low power mode sleep enabled";
	fi;

	if [ -e "/sys/class/lcd/panel/power_reduce" ]; then
		write /sys/class/lcd/panel/power_reduce "1"
		sendToLog "LCD power reduce enabled";
	fi;

	if [ -e "/sys/module/pm2/parameters/idle_sleep_mode" ]; then
		write /sys/module/pm2/parameters/idle_sleep_mode "Y"
		sendToLog "PM2 module idle sleep mode enabled";
	fi;

	sendToLog "Battery improvements are enabled";
	sendToLog "$divider";
}

#
# Doze optimization
#
dozeOptimization() {

	if [ "$api" -ge 23 ]; then
		if [ "$1" = "1" ]; then
			sendToLog "Enabling doze optimization";

			# Get lockScreen timeout value to delay enter doze and avoid not locking device
			lockScreenTimeout=$(settings get secure lock_screen_lock_after_timeout)
			
			case $lockScreenTimeout in
				''|*[!0-9]*) lockScreenTimeout=5000 ;;
				*) lockScreenTimeout=$lockScreenTimeout ;;
			esac
			
			if [ $lockScreenTimeout -eq 0 ]; then 
				lockScreenTimeout=$((lockScreenTimeout+1000))
			fi

			lightDozeTimeout=$lockScreenTimeout
			deepDozeTimeout=$((lockScreenTimeout+20000))

			lightAfterInactiveTo=$lightDozeTimeout
			lightPreIdleTo="60000"
			lightIdleTo="180000"
			lightIdleFactor="2.0"
			lightMaxIdleTo="240000"
			lightIdleMaintenanceMinBudget="60000"
			lightIdleMaintenanceMaxBudget="180000"
			minLightMaintenanceTime="5000"
			minDeepMaintenanceTime="30000"
			inactiveTo=$deepDozeTimeout
			sensingTo="0"
			locatingTo="0"
			locationAccuracy="20.0"
			motionInactiveTo="0"
			idleAfterInactiveTo="0"
			idlePendingTo="60000"
			maxIdlePendingTo="120000"
			idlePendingFactor="2.0"
			idleTo="900000"
			maxIdleTo="21600000"
			idleFactor="2.0"
			minTimeToAlarm="600000"
			maxTempAppWhitelistDuration="10000"
			mmsTempAppWhitelistDuration="10000"
			smsTempAppWhitelistDuration="10000"
			notificationWhitelistDuration="30000"

			if [ "$api" -gt 23 ]; then
				parameters="inactive_to=$inactiveTo,sensing_to=$sensingTo,locating_to=$locatingTo,location_accuracy=$locationAccuracy,motion_inactive_to=$motionInactiveTo,idle_after_inactive_to=$idleAfterInactiveTo,idle_pending_to=$idlePendingTo,max_idle_pending_to=$maxIdlePendingTo,idle_pending_factor=$idlePendingFactor,idle_to=$idleTo,max_idle_to=$maxIdleTo,idle_factor=$idleFactor,min_time_to_alarm=$minTimeToAlarm,max_temp_app_whitelist_duration=$maxTempAppWhitelistDuration,mms_temp_app_whitelist_duration=$mmsTempAppWhitelistDuration,sms_temp_app_whitelist_duration=$smsTempAppWhitelistDuration,light_after_inactive_to=$lightAfterInactiveTo,light_pre_idle_to=$lightPreIdleTo,light_idle_to=$lightIdleTo,light_idle_factor=$lightIdleFactor,light_max_idle_to=$lightMaxIdleTo,light_idle_maintenance_min_budget=$lightIdleMaintenanceMinBudget,light_idle_maintenance_max_budget=$lightIdleMaintenanceMaxBudget,min_light_maintenance_time=$minLightMaintenanceTime,min_deep_maintenance_time=$minDeepMaintenanceTime,notification_whitelist_duration=$notificationWhitelistDuration"
			else
				parameters="inactive_to=$inactiveTo,sensing_to=$sensingTo,locating_to=$locatingTo,location_accuracy=$locationAccuracy,motion_inactive_to=$motionInactiveTo,idle_after_inactive_to=$idleAfterInactiveTo,idle_pending_to=$idlePendingTo,max_idle_pending_to=$maxIdlePendingTo,idle_pending_factor=$idlePendingFactor,idle_to=$idleTo,max_idle_to=$maxIdleTo,idle_factor=$idleFactor,min_time_to_alarm=$minTimeToAlarm,max_temp_app_whitelist_duration=$maxTempAppWhitelistDuration,mms_temp_app_whitelist_duration=$mmsTempAppWhitelistDuration,sms_temp_app_whitelist_duration=$smsTempAppWhitelistDuration"
			fi

			settings put global device_idle_constants $parameters

			sendToLog "device_idle_constants=$parameters";
			sendToLog "Doze optimization enabled";
		elif [ "$1" = "0" ]; then

			sendToLog "Doze optimization disabled";
		fi
	else
		sendToLog "Your device don't support doze";
	fi

	sendToLog "$divider";
}

#
# CPU Optimization battery profile
#
cpuOptimizationBattery() {
	sendToLog "Applying power saving CPU optimization...";

	if [ -e "/sys/devices/system/cpu/cpuidle/use_deepest_state" ]; then
		write /sys/devices/system/cpu/cpuidle/use_deepest_state "1"
		sendToLog "Enable deepest CPU idle state";
	fi;

	# Disable krait voltage boost
	if [ -e "/sys/module/acpuclock_krait/parameters/boost" ];  then
		write /sys/module/acpuclock_krait/parameters/boost "N"
		sendToLog "Disable Krait voltage boost";
	fi;

	if [ -e "/sys/module/workqueue/parameters/power_efficient" ]; then
		lockFile /sys/module/workqueue/parameters/power_efficient "Y"
		sendToLog "Power-save workqueues enabled, scheduling workqueues on awake CPUs to save power."
	fi;

	if [ -e /sys/module/cpu_input_boost/parameters/input_boost_duration ]; then
		write /sys/module/cpu_input_boost/parameters/input_boost_duration "0"
		sendToLog "CPU Boost Input Duration=0"
	fi;

	if [ -e /sys/module/cpu_boost/parameters/input_boost_ms ]; then
		write /sys/module/cpu_boost/parameters/input_boost_ms "0"
		sendToLog "CPU Boost Input Ms=0"
	fi;

	if [ -e /sys/module/cpu_boost/parameters/input_boost_ms_s2 ]; then
		write /sys/module/cpu_boost/parameters/input_boost_ms_s2 "0"
		sendToLog "CPU Boost Input Ms_S2=0"
	fi;

	if [ -e /sys/module/cpu_boost/parameters/dynamic_stune_boost ]; then
		write /sys/module/cpu_boost/parameters/dynamic_stune_boost "0"
		sendToLog "CPU Boost Dyn_Stune_Boost=0"
	fi;

	if [ -e /sys/module/cpu_input_boost/parameters/dynamic_stune_boost ]; then
		write /sys/module/cpu_input_boost/parameters/dynamic_stune_boost "0"
		sendToLog "CPU input boost Dyn_Stune_Boost=0"
	fi;

	if [ -e /sys/module/cpu_input_boost/parameters/general_stune_boost ]; then
		write /sys/module/cpu_input_boost/parameters/general_stune_boost "10"
		sendToLog "CPU input boost General_Stune_Boost=10"
	fi;

	if [ -e /sys/module/dsboost/parameters/input_boost_duration ]; then
		write /sys/module/dsboost/parameters/input_boost_duration "0"
		sendToLog "Dsboost Input Boost Duration=0"
	fi;

	if [ -e /sys/module/dsboost/parameters/input_stune_boost ]; then
		write /sys/module/dsboost/parameters/input_stune_boost "0"
		sendToLog "Dsboost Input Stune Boost Duration=0"
	fi;

	if [ -e /sys/module/dsboost/parameters/sched_stune_boost ]; then
		write /sys/module/dsboost/parameters/sched_stune_boost "0"
		sendToLog "Dsboost Sched_Stune_Boost=0"
	fi;

	if [ -e /sys/module/dsboost/parameters/cooldown_boost_duration ]; then
		write /sys/module/dsboost/parameters/cooldown_boost_duration "0"
		sendToLog "Dsboost Cooldown_Boost_Duration=0"
	fi;

	if [ -e /sys/module/dsboost/parameters/cooldown_stune_boost ]; then
		write /sys/module/dsboost/parameters/cooldown_stune_boost "0"
		sendToLog "Dsboost Cooldown_Stune_Boost=0"
	fi;

	# CPU CTL
	if [ -e /dev/cpuctl/cpu.rt_period_us ]; then
		write /dev/cpuctl/cpu.rt_period_us "1000000"
		sendToLog "cpu.rt_period_us=1000000"
	fi;

	if [ -e /dev/cpuctl/cpu.rt_runtime_us ]; then
		write /dev/cpuctl/cpu.rt_period_us "950000"
		sendToLog "cpu.rt_runtime_us=950000"
	fi;

	sched_rt_period_us=/proc/sys/kernel/sched_rt_period_us
	if [ -e $sched_rt_period_us ]; then
		write $sched_rt_period_us "1000000"
		sendToLog "$sched_rt_period_us=1000000"
	fi;

	sched_rt_runtime_us=/proc/sys/kernel/sched_rt_runtime_us
	if [ -e $sched_rt_runtime_us ]; then
		write $sched_rt_runtime_us "950000"
		sendToLog "$sched_rt_runtime_us=950000"
	fi;

	sched_wake_to_idle=/proc/sys/kernel/sched_wake_to_idle
	if [ -e $sched_wake_to_idle ]; then
		write $sched_wake_to_idle "0"
		sendToLog "$sched_wake_to_idle=0"
	fi;

	# Disable touch boost
	touchboost=/sys/module/msm_performance/parameters/touchboost
	if [ -e $touchboost ]; then
		write $touchboost "0"
		sendToLog "$touchboost=0"
	fi;

	touch_boost=/sys/power/pnpmgr/touch_boost
	if [ -e $touch_boost ]; then
		write $touch_boost "N"
		sendToLog "$touch_boost=N"
	fi;

	#Disable CPU Boost
	boost_ms=/sys/module/cpu_boost/parameters/boost_ms
	if [ -e $boost_ms ]; then
		write $boost_ms "N"
		sendToLog "$boost_ms=N"
	fi;

	sched_boost_on_input=/sys/module/cpu_boost/parameters/sched_boost_on_input
	if [ -e $sched_boost_on_input ]; then
		write $sched_boost_on_input "N"
		sendToLog "$sched_boost_on_input=N"
	fi;
	
	sh $CPUSET_TUNER 1
	
	stune_background_prefer_idle="/dev/stune/background/schedtune.prefer_idle"
	if [ -e $stune_background_prefer_idle ]; then
		write $stune_background_prefer_idle "0"
		sendToLog "$stune_background_prefer_idle=0"
	fi
	
	stune_foreground_prefer_idle="/dev/stune/foreground/schedtune.prefer_idle"
	if [ -e $stune_foreground_prefer_idle ]; then
		write $stune_foreground_prefer_idle "0"
		sendToLog "$stune_foreground_prefer_idle=0"
	fi
	
	stune_topapp_prefer_idle="/dev/stune/top-app/schedtune.prefer_idle"
	if [ -e $stune_topapp_prefer_idle ]; then
		write $stune_topapp_prefer_idle "1"
		sendToLog "$stune_topapp_prefer_idle=1"
	fi
	
	stune_global_prefer_idle="/dev/stune/schedtune.prefer_idle"
	if [ -e $stune_global_prefer_idle ]; then
		write $stune_global_prefer_idle "0"
		sendToLog "$stune_global_prefer_idle=0"
	fi
	
	stune_rt_prefer_idle="/dev/stune/rt/schedtune.prefer_idle"
	if [ -e $stune_rt_prefer_idle ]; then
		write $stune_rt_prefer_idle "0"
		sendToLog "$stune_rt_prefer_idle=0"
	fi

	sendToLog "Power saving CPU optimization applied";
	sendToLog "$divider";
}

#
# CPU Optimization balanced profile
#
cpuOptimizationBalanced() {
	sendToLog "Applying balanced CPU optimization...";
		
	if [ -e "/sys/devices/system/cpu/cpuidle/use_deepest_state" ]; then
		write /sys/devices/system/cpu/cpuidle/use_deepest_state "1"
		sendToLog "Enable deepest CPU idle state";
	fi;

	# Disable krait voltage boost
	if [ -e "/sys/module/acpuclock_krait/parameters/boost" ];  then
		write /sys/module/acpuclock_krait/parameters/boost "N"
		sendToLog "Disable Krait voltage boost";
	fi;

	if [ -e "/sys/module/workqueue/parameters/power_efficient" ]; then
		lockFile /sys/module/workqueue/parameters/power_efficient "N"
		sendToLog "Power-save workqueues disabled, scheduling workqueues on awake CPUs to save power."
	fi;

	if [ -e /sys/module/cpu_input_boost/parameters/input_boost_duration ]; then
		write /sys/module/cpu_input_boost/parameters/input_boost_duration "60"
		sendToLog "CPU Boost Input Duration=60"
	fi;

	if [ -e /sys/module/cpu_boost/parameters/input_boost_ms ]; then
		write /sys/module/cpu_boost/parameters/input_boost_ms "60"
		sendToLog "CPU Boost Input Ms=60"
	fi;

	if [ -e /sys/module/cpu_boost/parameters/input_boost_ms_s2 ]; then
		write /sys/module/cpu_boost/parameters/input_boost_ms_s2 "30"
		sendToLog "CPU Boost Input Ms_S2=30"
	fi;

	if [ -e /sys/module/cpu_boost/parameters/dynamic_stune_boost ]; then
		write /sys/module/cpu_boost/parameters/dynamic_stune_boost "20"
		sendToLog "CPU Boost Dyn_Stune_Boost=20"
	fi;

	if [ -e /sys/module/cpu_input_boost/parameters/dynamic_stune_boost ]; then
		write /sys/module/cpu_input_boost/parameters/dynamic_stune_boost "20"
		sendToLog "CPU input boost Dyn_Stune_Boost=20"
	fi;

	if [ -e /sys/module/cpu_input_boost/parameters/general_stune_boost ]; then
		write /sys/module/cpu_input_boost/parameters/general_stune_boost "60"
		sendToLog "CPU input boost General_Stune_Boost=60"
	fi;

	if [ -e /sys/module/dsboost/parameters/input_boost_duration ]; then
		write /sys/module/dsboost/parameters/input_boost_duration "60"
		sendToLog "Dsboost Input Boost Duration=60"
	fi;

	if [ -e /sys/module/dsboost/parameters/input_stune_boost ]; then
		write /sys/module/dsboost/parameters/input_stune_boost "60"
		sendToLog "Dsboost Input Stune Boost Duration=60"
	fi;

	if [ -e /sys/module/dsboost/parameters/sched_stune_boost ]; then
		write /sys/module/dsboost/parameters/sched_stune_boost "10"
		sendToLog "Dsboost Sched_Stune_Boost=10"
	fi;

	if [ -e /sys/module/dsboost/parameters/cooldown_boost_duration ]; then
		write /sys/module/dsboost/parameters/cooldown_boost_duration "60"
		sendToLog "Dsboost Cooldown_Boost_Duration=60"
	fi;

	if [ -e /sys/module/dsboost/parameters/cooldown_stune_boost ]; then
		write /sys/module/dsboost/parameters/cooldown_stune_boost "10"
		sendToLog "Dsboost Cooldown_Stune_Boost=10"
	fi;

	# CPU CTL
	if [ -e /dev/cpuctl/cpu.rt_period_us ]; then
		write /dev/cpuctl/cpu.rt_period_us "1000000"
		sendToLog "cpu.rt_period_us=1000000"
	fi;

	if [ -e /dev/cpuctl/cpu.rt_runtime_us ]; then
		write /dev/cpuctl/cpu.rt_period_us "950000"
		sendToLog "cpu.rt_runtime_us=950000"
	fi;

	sched_rt_period_us=/proc/sys/kernel/sched_rt_period_us
	if [ -e $sched_rt_period_us ]; then
		write $sched_rt_period_us "1000000"
		sendToLog "$sched_rt_period_us=1000000"
	fi;

	sched_rt_runtime_us=/proc/sys/kernel/sched_rt_runtime_us
	if [ -e $sched_rt_runtime_us ]; then
		write $sched_rt_runtime_us "950000"
		sendToLog "$sched_rt_runtime_us=950000"
	fi;

	sched_wake_to_idle=/proc/sys/kernel/sched_wake_to_idle
	if [ -e $sched_wake_to_idle ]; then
		write $sched_wake_to_idle "0"
		sendToLog "$sched_wake_to_idle=0"
	fi;

	# Disable touch boost
	touchboost=/sys/module/msm_performance/parameters/touchboost
	if [ -e $touchboost ]; then
		write $touchboost "0"
		sendToLog "$touchboost=0"
	fi;

	touch_boost=/sys/power/pnpmgr/touch_boost
	if [ -e $touch_boost ]; then
		write $touch_boost "N"
		sendToLog "$touch_boost=N"
	fi;

	#Disable CPU Boost
	boost_ms=/sys/module/cpu_boost/parameters/boost_ms
	if [ -e $boost_ms ]; then
		write $boost_ms "N"
		sendToLog "$boost_ms=N"
	fi;

	sched_boost_on_input=/sys/module/cpu_boost/parameters/sched_boost_on_input
	if [ -e $sched_boost_on_input ]; then
		write $sched_boost_on_input "N"
		sendToLog "$sched_boost_on_input=N"
	fi;
	
	sh $CPUSET_TUNER 2

	stune_background_prefer_idle="/dev/stune/background/schedtune.prefer_idle"
	if [ -e $stune_background_prefer_idle ]; then
		write $stune_background_prefer_idle "0"
		sendToLog "$stune_background_prefer_idle=0"
	fi
	
	stune_foreground_prefer_idle="/dev/stune/foreground/schedtune.prefer_idle"
	if [ -e $stune_foreground_prefer_idle ]; then
		write $stune_foreground_prefer_idle "0"
		sendToLog "$stune_foreground_prefer_idle=0"
	fi
	
	stune_topapp_prefer_idle="/dev/stune/top-app/schedtune.prefer_idle"
	if [ -e $stune_topapp_prefer_idle ]; then
		write $stune_topapp_prefer_idle "1"
		sendToLog "$stune_topapp_prefer_idle=1"
	fi
	
	stune_global_prefer_idle="/dev/stune/schedtune.prefer_idle"
	if [ -e $stune_global_prefer_idle ]; then
		write $stune_global_prefer_idle "0"
		sendToLog "$stune_global_prefer_idle=0"
	fi
	
	stune_rt_prefer_idle="/dev/stune/rt/schedtune.prefer_idle"
	if [ -e $stune_rt_prefer_idle ]; then
		write $stune_rt_prefer_idle "0"
		sendToLog "$stune_rt_prefer_idle=0"
	fi

	sendToLog "Balanced CPU optimization applied";
	sendToLog "$divider";
}

#
# CPU Optimization performance profile
#
cpuOptimizationPerformance() {
	sendToLog "Applying performance CPU optimization...";

	if [ -e "/sys/devices/system/cpu/cpuidle/use_deepest_state" ]; then
		write /sys/devices/system/cpu/cpuidle/use_deepest_state "1"
		sendToLog "Enable deepest CPU idle state";
	fi;

	# Disable krait voltage boost
	if [ -e "/sys/module/acpuclock_krait/parameters/boost" ];  then
		write /sys/module/acpuclock_krait/parameters/boost "Y"
		sendToLog "Enable Krait voltage boost";
	fi;

	if [ -e "/sys/module/workqueue/parameters/power_efficient" ]; then
		lockFile /sys/module/workqueue/parameters/power_efficient "N"
		sendToLog "Power-save workqueues disabled, scheduling workqueues on awake CPUs to save power."
	fi;

	if [ -e /sys/module/cpu_input_boost/parameters/input_boost_duration ]; then
		write /sys/module/cpu_input_boost/parameters/input_boost_duration "120"
		sendToLog "CPU Boost Input Duration=120"
	fi;

	if [ -e /sys/module/cpu_boost/parameters/input_boost_ms ]; then
		write /sys/module/cpu_boost/parameters/input_boost_ms "120"
		sendToLog "CPU Boost Input Ms=120"
	fi;

	if [ -e /sys/module/cpu_boost/parameters/input_boost_ms_s2 ]; then
		write /sys/module/cpu_boost/parameters/input_boost_ms_s2 "50"
		sendToLog "CPU Boost Input Ms_S2=50"
	fi;

	if [ -e /sys/module/cpu_boost/parameters/dynamic_stune_boost ]; then
		write /sys/module/cpu_boost/parameters/dynamic_stune_boost "30"
		sendToLog "CPU Boost Dyn_Stune_Boost=30"
	fi;

	if [ -e /sys/module/cpu_input_boost/parameters/dynamic_stune_boost ]; then
		write /sys/module/cpu_input_boost/parameters/dynamic_stune_boost "30"
		sendToLog "CPU input boost Dyn_Stune_Boost=30"
	fi;

	if [ -e /sys/module/cpu_input_boost/parameters/general_stune_boost ]; then
		write /sys/module/cpu_input_boost/parameters/general_stune_boost "10"
		sendToLog "CPU input boost General_Stune_Boost=10"
	fi;

	if [ -e /sys/module/dsboost/parameters/input_boost_duration ]; then
		write /sys/module/dsboost/parameters/input_boost_duration "120"
		sendToLog "Dsboost Input Boost Duration=120"
	fi;

	if [ -e /sys/module/dsboost/parameters/input_stune_boost ]; then
		write /sys/module/dsboost/parameters/input_stune_boost "120"
		sendToLog "Dsboost Input Stune Boost Duration=120"
	fi;

	if [ -e /sys/module/dsboost/parameters/sched_stune_boost ]; then
		write /sys/module/dsboost/parameters/sched_stune_boost "10"
		sendToLog "Dsboost Sched_Stune_Boost=10"
	fi;

	if [ -e /sys/module/dsboost/parameters/cooldown_boost_duration ]; then
		write /sys/module/dsboost/parameters/cooldown_boost_duration "120"
		sendToLog "Dsboost Cooldown_Boost_Duration=120"
	fi;

	if [ -e /sys/module/dsboost/parameters/cooldown_stune_boost ]; then
		write /sys/module/dsboost/parameters/cooldown_stune_boost "10"
		sendToLog "Dsboost Cooldown_Stune_Boost=10"
	fi;

	# CPU CTL
	if [ -e /dev/cpuctl/cpu.rt_period_us ]; then
		write /dev/cpuctl/cpu.rt_period_us "1000000"
		sendToLog "cpu.rt_period_us=1000000"
	fi;

	if [ -e /dev/cpuctl/cpu.rt_runtime_us ]; then
		write /dev/cpuctl/cpu.rt_period_us "950000"
		sendToLog "cpu.rt_runtime_us=950000"
	fi;

	sched_rt_period_us=/proc/sys/kernel/sched_rt_period_us
	if [ -e $sched_rt_period_us ]; then
		write $sched_rt_period_us "1000000"
		sendToLog "$sched_rt_period_us=1000000"
	fi;

	sched_rt_runtime_us=/proc/sys/kernel/sched_rt_runtime_us
	if [ -e $sched_rt_runtime_us ]; then
		write $sched_rt_runtime_us "950000"
		sendToLog "$sched_rt_runtime_us=950000"
	fi;


	sched_wake_to_idle=/proc/sys/kernel/sched_wake_to_idle
	if [ -e $sched_wake_to_idle ]; then
		write $sched_wake_to_idle "0"
		sendToLog "$sched_wake_to_idle=0"
	fi;

	# Disable touch boost
	touchboost=/sys/module/msm_performance/parameters/touchboost
	if [ -e $touchboost ]; then
		write $touchboost "0"
		sendToLog "$touchboost=0"
	fi;

	touch_boost=/sys/power/pnpmgr/touch_boost
	if [ -e $touch_boost ]; then
		write $touch_boost "N"
		sendToLog "$touch_boost=N"
	fi;

	#Disable CPU Boost
	boost_ms=/sys/module/cpu_boost/parameters/boost_ms
	if [ -e $boost_ms ]; then
		write $boost_ms "N"
		sendToLog "$boost_ms=N"
	fi;

	sched_boost_on_input=/sys/module/cpu_boost/parameters/sched_boost_on_input
	if [ -e $sched_boost_on_input ]; then
		write $sched_boost_on_input "N"
		sendToLog "$sched_boost_on_input=N"
	fi;

	sh $CPUSET_TUNER 3
	
	stune_background_prefer_idle="/dev/stune/background/schedtune.prefer_idle"
	if [ -e $stune_background_prefer_idle ]; then
		write $stune_background_prefer_idle "0"
		sendToLog "$stune_background_prefer_idle=0"
	fi
	
	stune_foreground_prefer_idle="/dev/stune/foreground/schedtune.prefer_idle"
	if [ -e $stune_foreground_prefer_idle ]; then
		write $stune_foreground_prefer_idle "0"
		sendToLog "$stune_foreground_prefer_idle=0"
	fi
	
	stune_topapp_prefer_idle="/dev/stune/top-app/schedtune.prefer_idle"
	if [ -e $stune_topapp_prefer_idle ]; then
		write $stune_topapp_prefer_idle "1"
		sendToLog "$stune_topapp_prefer_idle=1"
	fi
	
	stune_global_prefer_idle="/dev/stune/schedtune.prefer_idle"
	if [ -e $stune_global_prefer_idle ]; then
		write $stune_global_prefer_idle "0"
		sendToLog "$stune_global_prefer_idle=0"
	fi

	stune_rt_prefer_idle="/dev/stune/rt/schedtune.prefer_idle"
	if [ -e $stune_rt_prefer_idle ]; then
		write $stune_rt_prefer_idle "0"
		sendToLog "$stune_rt_prefer_idle=0"
	fi
	
	sendToLog "Performance CPU optimization applied";
	sendToLog "$divider";
}

governorTuner() {
	if [ "$1" = "1" ] || [ "$1" = "2" ] || [ "$1" = "3" ]; then
		sendToLog "Starting governor tuner background service"
		sh $BINARY_DIR/governor_tuner &

		sendToLog "Successfully started governor tuner background service, changes will be done in a while"
	else 
		sendToLog "Cannot start governor tuner, wrong or missing argument"
	fi
	
	sendToLog "$divider";
}

entropy() {
	if [ "$1" = "1" ]; then
		sendToLog "Activating light entropy profile..."
		$BUSYBOX sysctl -e -w kernel.random.read_wakeup_threshold=64
		$BUSYBOX sysctl -e -w kernel.random.write_wakeup_threshold=128
		$BUSYBOX sysctl -e -w kernel.random.urandom_min_reseed_secs=90
		sendToLog "Light entropy profile activated"
	
	elif [ "$1" = "2" ]; then
		sendToLog "Activating enlarger entropy profile..."
		$BUSYBOX sysctl -e -w kernel.random.read_wakeup_threshold=128
		$BUSYBOX sysctl -e -w kernel.random.write_wakeup_threshold=896
		$BUSYBOX sysctl -e -w kernel.random.urandom_min_reseed_secs=90
		sendToLog "Enlarger entropy profile activated"
		
	elif [ "$1" = "3" ]; then	
		sendToLog "Activating moderate entropy profile..."
		$BUSYBOX sysctl -e -w kernel.random.read_wakeup_threshold=128
		$BUSYBOX sysctl -e -w kernel.random.write_wakeup_threshold=256
		$BUSYBOX sysctl -e -w kernel.random.urandom_min_reseed_secs=90
		sendToLog "Moderate entropy profile activated"
		
	elif [ "$1" = "4" ]; then	
		sendToLog "Activating aggressive entropy profile..."
		$BUSYBOX sysctl -e -w kernel.random.read_wakeup_threshold=512
		$BUSYBOX sysctl -e -w kernel.random.write_wakeup_threshold=1024
		$BUSYBOX sysctl -e -w kernel.random.urandom_min_reseed_secs=90
		sendToLog "Aggressive entropy profile activated"
	fi

	sendToLog "$divider";
}

gpuOptimizer() {
	if [ "$1" = "1" ]; then
		profile="power saving"
	elif [ "$1" = "2" ]; then
		profile="balanced"
	elif [ "$1" = "3" ]; then
		profile="performance"
	fi
	
	sendToLog "Applying $profile GPU optimization...";

	# GPU related tweaks
	if [ -d "/sys/class/kgsl/kgsl-3d0" ]; then
		gpu="/sys/class/kgsl/kgsl-3d0"
	elif [ -d "/sys/devices/platform/kgsl-3d0.0/kgsl/kgsl-3d0" ]; then
		gpu="/sys/devices/platform/kgsl-3d0.0/kgsl/kgsl-3d0"
	elif [ -d "/sys/devices/soc/*.qcom,kgsl-3d0/kgsl/kgsl-3d0" ]; then
		gpu="/sys/devices/soc/*.qcom,kgsl-3d0/kgsl/kgsl-3d0"
	elif [ -d "/sys/devices/soc.0/*.qcom,kgsl-3d0/kgsl/kgsl-3d0" ]; then
		gpu="/sys/devices/soc.0/*.qcom,kgsl-3d0/kgsl/kgsl-3d0"
	elif [ -d "/sys/devices/platform/*.gpu/devfreq/*.gpu" ]; then
		gpu="/sys/devices/platform/*.gpu/devfreq/*.gpu"
	elif [ -d "/sys/devices/platform/gpusysfs" ]; then
		gpu="/sys/devices/platform/gpusysfs"
	elif [ -d "/sys/devices/*.mali" ]; then
		gpu="/sys/devices/*.mali"
	elif [ -d "/sys/devices/*.gpu" ]; then
		gpu="/sys/devices/*.gpu"
	elif [ -d "/sys/devices/platform/mali.0" ]; then
		gpu="/sys/devices/platform/mali.0"
	elif [ -d "/sys/devices/platform/mali-*.0" ]; then
		gpu="/sys/devices/platform/mali-*.0"
	elif [ -d "/sys/module/mali/parameters" ]; then
		gpu="/sys/module/mali/parameters"
	elif [ -d "/sys/class/misc/mali0" ]; then
		gpu="/sys/class/misc/mali0"
	elif [ -d "/sys/kernel/gpu" ]; then
		gpu="/sys/kernel/gpu"
	fi

	if [ "$memTotal" -lt 3072 ]; then
		resetprop ro.hwui.texture_cache_size $((memTotal*10/100/2));
		resetprop ro.hwui.layer_cache_size $((memTotal*5/100/2));
		resetprop ro.hwui.path_cache_size $((memTotal*2/100/2));
		resetprop ro.hwui.r_buffer_cache_size $((memTotal/100/2));
		resetprop ro.hwui.drop_shadow_cache_size $((memTotal/100/2));
		resetprop ro.hwui.texture_cache_flushrate 0.3
	else 
		resetprop ro.hwui.texture_cache_size $((memTotal*10/100));
		resetprop ro.hwui.layer_cache_size $((memTotal*5/100));
		resetprop ro.hwui.path_cache_size $((memTotal*2/100));
		resetprop ro.hwui.r_buffer_cache_size $((memTotal/100));
		resetprop ro.hwui.drop_shadow_cache_size $((memTotal/100));
		resetprop ro.hwui.texture_cache_flushrate 0.3
	fi
	sendToLog "Optimized GPU caches";
	#dumpsys SurfaceFlinger --dispsync
	
	if [ -e /proc/gpufreq/gpufreq_limited_thermal_ignore ]; then
		if [ "$1" = "1" ]; then
			write /proc/gpufreq/gpufreq_limited_thermal_ignore "0"
			sendToLog "Enabled gpufreq thermal"
			
		elif [ "$1" = "2" ]; then
			write /proc/gpufreq/gpufreq_limited_thermal_ignore "1"
			sendToLog "Disabled gpufreq thermal"
			
		elif [ "$1" = "3" ]; then
			write /proc/gpufreq/gpufreq_limited_thermal_ignore "1"
			sendToLog "Disabled gpufreq thermal"
		fi
	fi

	# Dynamic voltage frequency scheduler for gpu on
	if [ -e /proc/mali/dvfs_enable ]; then
		write /proc/mali/dvfs_enable "1"		
		sendToLog "dvfs enabled"
	fi
	
	if [ -e /sys/module/pvrsrvkm/parameters/gpu_dvfs_enable ]; then
		write /sys/module/pvrsrvkm/parameters/gpu_dvfs_enable "1"		
		sendToLog "dvfs enabled"
	fi
	
	if [ -e /sys/module/simple_gpu_algorithm/parameters/simple_gpu_activate ]; then
		write /sys/module/simple_gpu_algorithm/parameters/simple_gpu_activate "1"
		sendToLog "Simple GPU algorithm enabled"
	fi;
	
	# Adreno idler
	if [ -e /sys/module/adreno_idler/parameters/adreno_idler_active ]; then
		write /sys/module/adreno_idler/parameters/adreno_idler_active "Y"
		
		if [ "$1" = "1" ]; then
			write /sys/module/adreno_idler/parameters/adreno_idler_idleworkload "10000"
			write /sys/module/adreno_idler/parameters/adreno_idler_downdifferential "35"
			write /sys/module/adreno_idler/parameters/adreno_idler_idlewait "25"
			
		elif [ "$1" = "2" ]; then
			write /sys/module/adreno_idler/parameters/adreno_idler_idleworkload "6000"
			write /sys/module/adreno_idler/parameters/adreno_idler_downdifferential "15"
			write /sys/module/adreno_idler/parameters/adreno_idler_idlewait "25"
			
		elif [ "$1" = "3" ]; then
			write /sys/module/adreno_idler/parameters/adreno_idler_idleworkload "5000"
			write /sys/module/adreno_idler/parameters/adreno_idler_downdifferential "15"
			write /sys/module/adreno_idler/parameters/adreno_idler_idlewait "15"
		fi
		sendToLog "Enabled and tweaked adreno idler"
	fi

	# Adreni boost 0 for off , 1 for low , 2 for medium , 3 for high
	if [ -e $gpu/devfreq/adrenoboost ]; then
		if [ "$1" = "1" ]; then
			write $gpu/devfreq/adrenoboost "0"
			sendToLog "Adreno boost is set to 0"
		elif [ "$1" = "2" ]; then
			write $gpu/devfreq/adrenoboost "1"
			sendToLog "Adreno boost is set to 1"
		elif [ "$1" = "3" ]; then
			write $gpu/devfreq/adrenoboost "2"
			sendToLog "Adreno boost is set to 2"
		fi
	fi

	# GPU freq throttling
	if [ -e $gpu/throttling ]; then
		if [ "$1" = "1" ]; then
			write $gpu/throttling "1"
			sendToLog "GPU throttling enabled"
		elif [ "$1" = "2" ]; then
			write $gpu/throttling "1"
			sendToLog "GPU throttling enabled"
		elif [ "$1" = "3" ]; then
			write $gpu/throttling "0"
			sendToLog "GPU throttling disabled"
		fi
	fi
	
	# GPU idle timer, the time after the GPU going idle
	if [ -e $gpu/idle_time ]; then
		if [ "$1" = "1" ]; then
			write $gpu/idle_time "50"
			sendToLog "Setting GPU idle timer to 50"
		elif [ "$1" = "2" ]; then
			write $gpu/idle_time "200"
			sendToLog "Setting GPU idle timer to 200"
		elif [ "$1" = "3" ]; then
			write $gpu/idle_time "1000"
		sendToLog "Setting GPU idle timer to 1000"
		fi
	fi
	
	# Setting up the force GPU clock, this will keep clocks on until the idle timeout forces the power rail off
	if [ -e $gpu/force_clk_on ]; then
		if [ "$1" = "1" ]; then
			write $gpu/force_clk_on "0"
			sendToLog "Force clock disabled"
		elif [ "$1" = "2" ]; then
			write $gpu/force_clk_on "0"
			sendToLog "Force clock disabled"
		elif [ "$1" = "3" ]; then
			write $gpu/force_clk_on "1"
			sendToLog "Force clock enabled"
		fi
	fi
	
	# Keep the graphics power rail on permanently.
	# Enabling this can cause a pretty big drainage because the rail(power) is always on, so it'll be just on performance for now!
	if [ -e $gpu/force_rail_on ]; then
		if [ "$1" = "1" ]; then
			write $gpu/force_rail_on "0"
			sendToLog "force_rail_on disabled"
		elif [ "$1" = "2" ]; then
			write $gpu/force_rail_on "0"		
			sendToLog "force_rail_on disabled"
		elif [ "$1" = "3" ]; then
			write $gpu/force_rail_on "1"		
			sendToLog "force_rail_on enabled"
		fi
	fi
	
	if [ -e $gpu/force_no_nap ]; then
		write $gpu/force_no_nap "0"
		sendToLog "force_no_nap disabled"
	fi

	if [ -e $gpu/bus_split ]; then
		if [ "$1" = "1" ]; then
			write $gpu/bus_split "1"
			sendToLog "bus_split enabled"
		elif [ "$1" = "2" ]; then
			write $gpu/bus_split "1"
			sendToLog "bus_split enabled"
		elif [ "$1" = "3" ]; then
			write $gpu/bus_split "0"
			sendToLog "bus_split disabled"
		fi
	fi

	# Keep the bus vote on permanently, whatever that means I found it in some Qualcomm references
	# They mention that for full GPU performance it should be turned On. No side-effects
	if [ -e $gpu/force_bus_on ]; then
		if [ "$1" = "1" ]; then
			write $gpu/force_bus_on "0"
			sendToLog "force_bus_on disabled"
		elif [ "$1" = "2" ]; then
			write $gpu/force_bus_on "0"		
			sendToLog "force_bus_on disabled"
		elif [ "$1" = "3" ]; then
			write $gpu/force_bus_on "1"		
			sendToLog "force_bus_on enabled"
		fi
	fi
	
	sendToLog "GPU optimization has successfully applied $profile profile"
	sendToLog "$divider";
}

optimizeBuffers() {
	sendToLog "Changing GPU buffer count"

	setprop debug.egl.buffcount 4

	sendToLog "GPU buffer count set to 4"
	sendToLog "$divider";
}

renderOpenglesUsingGpu() {
	sendToLog "Setting GPU to render OpenGLES..."

	setprop debug.egl.hw 1

	sendToLog "GPU successfully set up to render OpenGLES"
	sendToLog "$divider";
}

useOpenglSkia() {
	sendToLog "Changing app rendering to skiagl..."

	setprop debug.hwui.renderer skiagl

	sendToLog "Rendering chaned to skiagl"
	sendToLog "$divider";
}

forceGpuRendering() {
	if [ $1 -eq 0 ]; then
		sendToLog "Disabling force GPU rendering..."
		setprop persist.sys.ui.hw 0
		sendToLog "Force GPU rendering successfully disabled"
	elif [ $1 -eq 1 ]; then
		sendToLog "Enabling force GPU rendering..."
		setprop persist.sys.ui.hw 1
		sendToLog "Force GPU rendering successfully enabled"
	fi
	 
	sendToLog "$divider";
}

force4xMsaa() {
	if [ $1 -eq 0 ]; then
		sendToLog "Disabling force 4x MSAA..."
		setprop debug.egl.force_msaa 0
		sendToLog "Force 4x MSAA successfully disabled"
	elif [ $1 -eq 1 ]; then
		sendToLog "Enabling force 4x MSAA..."
		setprop debug.egl.force_msaa 1
		sendToLog "Force 4x MSAA successfully enabled"
	fi
	 
	sendToLog "$divider";
}

enableIoStats() {
	sendToLog "Enabling I/O Stats..."

	blocks="/sys/block/*"

	for i in $blocks;
		do
			write "$i/queue/iostats" "1"
			sendToLog "iostats=1 in $i"
	done

	sendToLog "I/O Stats enabled"
	sendToLog "$divider";
}

disableIoStats() {
	sendToLog "Disabling I/O Stats..."

	blocks="/sys/block/*"

	for i in $blocks;
		do
			write "$i/queue/iostats" "0"
			sendToLog "iostats=0 in $i"
	done

	sendToLog "I/O Stats disabled"
	sendToLog "$divider";
}

ioBlocksOptimization() {
	if [ "$1" = "1" ]; then
		profile="battery"
	elif [ "$1" = "2" ]; then
		profile="balanced"
	elif [ "$1" = "3" ]; then
		profile="performance"
	fi
	
	sendToLog "Activating $profile I/O blocks optimization..."

	#This tuning parameter controls the maximum
	#number of inode table blocks that ext4's inode
	#table readahead algorithm will pre-read into
	#the buffer cache.  The default value is 32 blocks.
	ext4blocks="/sys/fs/ext4/*"
	for ext4block in $ext4blocks;
		do
		if [ "$1" = "1" ]; then
			if [ -e "$ext4block/inode_readahead_blks" ]; then
				write "$ext4block/inode_readahead_blks" "32"
				sendToLog "Pre-read cache of ext4 in $ext4block set to 32"
			fi
		elif [ "$1" = "2" ]; then
			if [ -e "$ext4block/inode_readahead_blks" ]; then
				write "$ext4block/inode_readahead_blks" "32"
				sendToLog "Pre-read cache of ext4 in $ext4block set to 32"
			fi
		elif [ "$1" = "3" ]; then
			if [ -e "$ext4block/inode_readahead_blks" ]; then
				write "$ext4block/inode_readahead_blks" "64"
				sendToLog "Pre-read cache of ext4 in $ext4block set to 64"
			fi
		fi
	done

	blocks="/sys/block/*"
	for i in $blocks;
		do
		
		#This file allows to turn off the disk entropy contribution. Default
		#value of this file is '1'(on).
		if [ -e "$i/queue/add_random" ]; then
			write "$i/queue/add_random" "0"
			sendToLog "add_random=0 in $i"
		fi
		
		#This enables the user to disable the lookup logic involved with IO
		#merging requests in the block layer. By default (0) all merges are
		#enabled. When set to 1 only simple one-hit merges will be tried. When
		#set to 2 no merge algorithms will be tried (including one-hit or more
		#complex tree/hash lookups).
		if [ -e "$i/queue/nomerges" ]; then
			write "$i/queue/nomerges" "2"
			sendToLog "nomerges=2 in $i"
		fi
			
		#If this option is '1', the block layer will migrate request completions to the
		#cpu "group" that originally submitted the request. For some workloads this
		#provides a significant reduction in CPU cycles due to caching effects.
		#For storage configurations that need to maximize distribution of completion
		#processing setting this option to '2' forces the completion to run on the
		#requesting cpu (bypassing the "group" aggregation logic).
		if [ "$1" = "1" ]; then
			if [ -e "$i/queue/rq_affinity" ]; then
				write "$i/queue/rq_affinity" "1"
				sendToLog "rq_affinity=1 in $i"
			fi
		
		elif [ "$1" = "2" ]; then
			if [ -e "$i/queue/rq_affinity" ]; then
				write "$i/queue/rq_affinity" "2"
				sendToLog "rq_affinity=2 in $i"
			fi
			
		elif [ "$1" = "3" ]; then
			if [ -e "$i/queue/rq_affinity" ]; then
				write "$i/queue/rq_affinity" "2"
				sendToLog "rq_affinity=2 in $i"
			fi	
		fi
		
		#This controls how many requests may be allocated in the block layer for
		#read or write requests. Note that the total allocated number may be twice
		#this amount, since it applies only to reads or writes (not the accumulated
		#sum).
		#To avoid priority inversion through request starvation, a request
		#queue maintains a separate request pool per each cgroup when
		#CONFIG_BLK_CGROUP is enabled, and this parameter applies to each such
		#per-block-cgroup request pool.  IOW, if there are N block cgroups,
		#each request queue may have up to N request pools, each independently
		#regulated by nr_requests.
		if [ "$1" = "1" ]; then
			if [ -e "$i/queue/nr_requests" ]; then
				write "$i/queue/nr_requests" "64"
				sendToLog "nr_requests=64 in $i"
			fi
		
		elif [ "$1" = "2" ]; then
			if [ -e "$i/queue/nr_requests" ]; then
				write "$i/queue/nr_requests" "128"
				sendToLog "nr_requests=128 in $i"
			fi
			
		elif [ "$1" = "3" ]; then
			if [ -e "$i/queue/nr_requests" ]; then
				write "$i/queue/nr_requests" "128"
				sendToLog "nr_requests=128 in $i"
			fi	
		fi
		
		#Maximum number of kilobytes to read-ahead for filesystems on this block
		#device.
		if [ "$1" = "1" ]; then
			case $i in 
			*"/sys/block/sd"*) 
				if [ -e "$i/queue/read_ahead_kb" ]; then
					write "$i/queue/read_ahead_kb" "512"
					sendToLog "read_ahead_kb=512 in $i"
				fi
			;;
			*"/sys/block/dm-"*) 
				if [ -e "$i/queue/read_ahead_kb" ]; then
					write "$i/queue/read_ahead_kb" "512"
					sendToLog "read_ahead_kb=512 in $i"
				fi
			;;
			*) 
				if [ -e "$i/queue/read_ahead_kb" ]; then
					write "$i/queue/read_ahead_kb" "128"
					sendToLog "read_ahead_kb=128 in $i"
				fi 
			;;
			esac
		
		elif [ "$1" = "2" ]; then
			case $i in 
			*"/sys/block/sd"*) 
				if [ -e "$i/queue/read_ahead_kb" ]; then
					write "$i/queue/read_ahead_kb" "512"
					sendToLog "read_ahead_kb=512 in $i"
				fi
			;;
			*"/sys/block/dm-"*) 
				if [ -e "$i/queue/read_ahead_kb" ]; then
					write "$i/queue/read_ahead_kb" "512"
					sendToLog "read_ahead_kb=512 in $i"
				fi
			;;
			*) 
				if [ -e "$i/queue/read_ahead_kb" ]; then
					write "$i/queue/read_ahead_kb" "128"
					sendToLog "read_ahead_kb=128 in $i"
				fi 
			;;
			esac
			
		elif [ "$1" = "3" ]; then
			case $i in 
			*"/sys/block/sd"*) 
				if [ -e "$i/queue/read_ahead_kb" ]; then
					write "$i/queue/read_ahead_kb" "1024"
					sendToLog "read_ahead_kb=1024 in $i"
				fi
			;;
			*"/sys/block/dm-"*) 
				if [ -e "$i/queue/read_ahead_kb" ]; then
					write "$i/queue/read_ahead_kb" "1024"
					sendToLog "read_ahead_kb=1024 in $i"
				fi
			;;
			*) 
				if [ -e "$i/queue/read_ahead_kb" ]; then
					write "$i/queue/read_ahead_kb" "256"
					sendToLog "read_ahead_kb=256 in $i"
				fi 
			;;
			esac
		fi
		
		# Tell scheduler that it's facing with non rotational drive to disable
		# unnecessary seek-reducing logic in the scheduler. We are not using rotational HDDs
		if [ -e "$i/queue/rotational" ]; then
			write "$i/queue/rotational" "0"
			sendToLog "rotational=0 in $i"
		fi

	done

	# MMC CRC disabled
	removable=/sys/module/mmc_core/parameters/removable
	if [ -e $removable ]; then
		write $removable "N"
		sendToLog "CRC Checks disabled $removable"
	fi;

	crc=/sys/module/mmc_core/parameters/crc
	if [ -e $crc ]; then
		write $crc "N"
		sendToLog "CRC Checks disabled $crc"
	fi;

	use_spi_crc=/sys/module/mmc_core/parameters/use_spi_crc
	if [ -e $use_spi_crc ]; then
		write $use_spi_crc "N"
		sendToLog "CRC Checks disabled $use_spi_crc"
	fi;

	sendToLog "Activating of $profile I/O blocks optimization is successful"
	sendToLog "$divider";
}

ioExtendedQueue() {
	sendToLog "Activating I/O extend queue..."

	blocks="/sys/block/*"

	for i in $blocks;
		do
		if [ -e "$i" ]; then
			write "$i/queue/nr_requests" "512"
			sendToLog "nr_requests=512 in $i"
		fi
	done

	sendToLog "I/O extend queue is activated"
	sendToLog "$divider";
}

schedulerTuner() {

sendToLog "Activating scheduler tuner..."
	
blocks="/sys/block/*"

for i in $blocks;
	do
	scheduler=$(getScheduler "$i")
		
	# deadline
	FIFO_BATCH="$i/queue/iosched/fifo_batch";
	FRONT_MERGES="$i/queue/iosched/front_merges";
	READ_EXPIRE="$i/queue/iosched/read_expire";
	WRITE_EXPIRE="$i/queue/iosched/write_expire";
	WRITES_STARVED="$i/queue/iosched/writes_starved";

	# anxiety
	MAX_WRITES_STARVED="$i/queue/iosched/max_writes_starved";

	# cfq
	BACK_SEEK_PENALTY="$i/queue/iosched/back_seek_penalty";
	FIFO_EXPIRE_ASYNC="$i/queue/iosched/fifo_expire_async";
	FIFO_EXPIRE_SYNC="$i/queue/iosched/fifo_expire_sync";
	GROUP_IDLE="$i/queue/iosched/group_idle";
	LOW_LATENCY="$i/queue/iosched/low_latency";
	QUANTUM="$i/queue/iosched/quantum";
	SLICE_ASYNC="$i/queue/iosched/slice_async";
	SLICE_ASYNC_RQ="$i/queue/iosched/slice_async_rq";
	SLICE_IDLE="$i/queue/iosched/slice_idle";
	SLICE_SYNC="$i/queue/iosched/slice_sync";
	TARGET_LATENCY="$i/queue/iosched/target_latency";

	# bfq
	MAX_BUDGET="$i/queue/iosched/max_budget";
	MAX_BUDGET_ASYNC_RQ="$i/queue/iosched/max_budget_async_rq";
	TIMEOUT_ASYNC="$i/queue/iosched/timeout_async";
	TIMEOUT_SYNC="$i/queue/iosched/timeout_sync";
	WR_COEOFF="$i/queue/iosched/wr_coeff";
	WR_MAX_SOFTRT_RATE="$i/queue/iosched/wr_max_softrt_rate";
	WR_MAX_TIME="$i/queue/iosched/wr_max_time";
	WR_MIN_IDLE_TIME="$i/queue/iosched/wr_min_idle_time";
	WR_MIN_INTER_ARR_ASYNC="$i/queue/iosched/wr_min_inter_arr_async";
	WR_RT_MAX_TIME="$i/queue/iosched/wr_rt_max_time";

	# row
	HP_READ_QUANTUM="$i/queue/iosched/hp_read_quantum";
	HP_SWRITE_QUANTUM="$i/queue/iosched/hp_swrite_quantum";
	LOW_STARV_LIMIT="$i/queue/iosched/low_starv_limit";
	LP_READ_QUANTUM="$i/queue/iosched/lp_read_quantum";
	LP_SWRITE_QUANTUM="$i/queue/iosched/lp_swrite_quantum";
	RD_IDLE_DATA="$i/queue/iosched/rd_idle_data";
	RD_IDLE_DATA_FREQ="$i/queue/iosched/rd_idle_data_freq";
	READ_IDLE="$i/queue/iosched/read_idle";
	READ_IDLE_FREQ="$i/queue/iosched/read_idle_freq";
	REG_STARV_LIMIT="$i/queue/iosched/reg_starv_limit";
	RP_READ_QUANTUM="$i/queue/iosched/rp_read_quantum";
	RP_SWRITE_QUANTUM="$i/queue/iosched/rp_swrite_quantum";
	RP_WRITE_QUANTUM="$i/queue/iosched/rp_write_quantum";

	# fiops
	ASYNC_SCALE="$i/queue/iosched/async_scale";
	READ_SCALE="$i/queue/iosched/read_scale";
	SYNC_SCALE="$i/queue/iosched/sync_scale";
	WRITE_SCALE="$i/queue/iosched/write_scale";

	# sio/sioplus
	ASYNC_READ_EXPIRE="$i/queue/iosched/async_read_expire";
	ASYNC_WRITE_EXPIRE="$i/queue/iosched/async_write_expire";
	SYNC_READ_EXPIRE="$i/queue/iosched/sync_read_expire";
	SYNC_WRITE_EXPIRE="$i/queue/iosched/sync_write_expire";

	# zen
	ASYNC_EXPIRE="$i/queue/iosched/async_expire";
	SYNC_EXPIRE="$i/queue/iosched/sync_expire";
	
	# Write log when found a scheduler in block
	# This log contains current scheduler in $i block
	if [ "$scheduler" != "none" ]; then
		sendToLog "Found $scheduler in $i"
	fi
	
	# deadline
	if [ "$scheduler" = "deadline" ]; then
		if [ -e "$FIFO_BATCH" ]; then
			write "$FIFO_BATCH" "8"
			sendToLog "fifo_batch=8 in $i"
		fi
		
		if [ -e "$FRONT_MERGES" ]; then
			write "$FRONT_MERGES" "1"
			sendToLog "front_merges=1 in $i"
		fi
		
		if [ -e "$READ_EXPIRE" ]; then
			write "$READ_EXPIRE" "250"
			sendToLog "read_expire=250 in $i"
		fi
		
		if [ -e "$WRITE_EXPIRE" ]; then
			write "$WRITE_EXPIRE" "2500"
			sendToLog "write_expire=2500 in $i"
		fi

		if [ -e "$WRITES_STARVED" ]; then
			write "$WRITES_STARVED" "1"
			sendToLog "writes_starved=1 in $i"
		fi

	# anxiety
	elif [ "$scheduler" = "anxiety" ]; then
		if [ -e "$MAX_WRITES_STARVED" ]; then
			write "$MAX_WRITES_STARVED" "4"
			sendToLog "max_writes_starved=4 in $i"
		fi

	# cfq
	elif [ "$scheduler" = "cfq" ]; then
		if [ -e "$BACK_SEEK_PENALTY" ]; then
			write "$BACK_SEEK_PENALTY" "1"
			sendToLog "back_seek_penalty=1 in $i"
		fi
		
		if [ -e "$FIFO_EXPIRE_ASYNC" ]; then
			write "$FIFO_EXPIRE_ASYNC" "330"
			sendToLog "fifo_expire_async=330 in $i"
		fi
		
		if [ -e "$FIFO_EXPIRE_SYNC" ]; then
			write "$FIFO_EXPIRE_SYNC" "80"
			sendToLog "fifo_expire_sync=80 in $i"
		fi
		
		if [ -e "$GROUP_IDLE" ]; then
			write "$GROUP_IDLE" "1"
			sendToLog "group_idle=1 in $i"
		fi
		
		if [ -e "$LOW_LATENCY" ]; then
			write "$LOW_LATENCY" "0"
			sendToLog "low_latency=0 in $i"
		fi
		
		if [ -e "$QUANTUM" ]; then
			write "$QUANTUM" "16"
			sendToLog "quantum=16 in $i"
		fi
		
		if [ -e "$SLICE_ASYNC" ]; then
			write "$SLICE_ASYNC" "50"
			sendToLog "slice_async=50 in $i"
		fi
		
		if [ -e "$SLICE_ASYNC_RQ" ]; then
			write "$SLICE_ASYNC_RQ" "2"
			sendToLog "slice_async_rq=2 in $i"
		fi
		
		if [ -e "$SLICE_IDLE" ]; then
			write "$SLICE_IDLE" "0"
			sendToLog "slice_idle=0 in $i"
		fi
		
		if [ -e "$SLICE_SYNC" ]; then
			write "$SLICE_SYNC" "60"
			sendToLog "slice_sync=60 in $i"
		fi
		
		if [ -e "$TARGET_LATENCY" ]; then
			write "$TARGET_LATENCY", true "30"
			sendToLog "target_latency=300 in $i"
		fi

	# bfq
	elif [ "$scheduler" = "bfq" ]; then
		if [ -e "$BACK_SEEK_PENALTY" ]; then
			write "$BACK_SEEK_PENALTY" "1"
			sendToLog "back_seek_penalty=1 in $i"
		fi
		
		if [ -e "$FIFO_EXPIRE_ASYNC" ]; then
			write "$FIFO_EXPIRE_ASYNC" "250"
			sendToLog "fifo_expire_async=250 in $i"
		fi
		
		if [ -e "$FIFO_EXPIRE_SYNC" ]; then
			write "$FIFO_EXPIRE_SYNC" "120"
			sendToLog "fifo_expire_sync=120 in $i"
		fi
		
		if [ -e "$LOW_LATENCY" ]; then
			write "$LOW_LATENCY" "0"
			sendToLog "low_latency=0 in $i"
		fi
		
		if [ -e "$MAX_BUDGET" ]; then
			write "$MAX_BUDGET" "0"
			sendToLog "max_budget=0 in $i"
		fi
		
		if [ -e "$MAX_BUDGET_ASYNC_RQ" ]; then
			write "$MAX_BUDGET_ASYNC_RQ" "4"
			sendToLog "max_budget_async_rq=4 in $i"
		fi
		
		if [ -e "$SLICE_IDLE" ]; then
			write "$SLICE_IDLE" "0"
			sendToLog "slice_idle=0 in $i"
		fi
		
		if [ -e "$TIMEOUT_ASYNC" ]; then
			write "$TIMEOUT_ASYNC" "40"
			sendToLog "timeout_async=40 in $i"
		fi
		
		if [ -e "$TIMEOUT_SYNC" ]; then
			write "$TIMEOUT_SYNC" "120"
			sendToLog "timeout_sync=120 in $i"
		fi
		
		if [ -e "$WR_COEOFF" ]; then
			write "$WR_COEOFF" "20"
			sendToLog "wr_coeff=20 in $i"
		fi
		
		if [ -e "$WR_MAX_SOFTRT_RATE" ]; then
			write "$WR_MAX_SOFTRT_RATE" "7000"
			sendToLog "wr_max_softrt_rate=7000 in $i"
		fi
		
		if [ -e "$WR_MAX_TIME" ]; then
			write "$WR_MAX_TIME" "2250"
			sendToLog "wr_max_time=2250 in $i"
		fi
		
		if [ -e "$WR_MIN_IDLE_TIME" ]; then
			write "$WR_MIN_IDLE_TIME" "2000"
			sendToLog "wr_min_idle_time=2000 in $i"
		fi
		
		if [ -e "$WR_MIN_INTER_ARR_ASYNC" ]; then
			write "$WR_MIN_INTER_ARR_ASYNC" "500"
			sendToLog "wr_min_inter_arr_async=500 in $i"
		fi
		
		if [ -e "$WR_RT_MAX_TIME" ]; then
			write "$WR_RT_MAX_TIME" "300"
			sendToLog "wr_rt_max_time=300 in $i"
		fi

	# row
	elif [ "$scheduler" = "row" ]; then
		if [ -e "$HP_READ_QUANTUM" ]; then
			write "$HP_READ_QUANTUM" "90"
			sendToLog "hp_read_quantum=90 in $i"
		fi
		
		if [ -e "$HP_SWRITE_QUANTUM" ]; then
			write "$HP_SWRITE_QUANTUM" "5"
			sendToLog "hp_swrite_quantum=5 in $i"
		fi
		
		if [ -e "$LOW_STARV_LIMIT" ]; then
			write "$LOW_STARV_LIMIT" "10000"
			sendToLog "low_starv_limit=10000 in $i"
		fi
		
		if [ -e "$LP_READ_QUANTUM" ]; then
			write "$LP_READ_QUANTUM" "3"
			sendToLog "lp_read_quantum=3 in $i"
		fi
		
		if [ -e "$LP_SWRITE_QUANTUM" ]; then
			write "$LP_SWRITE_QUANTUM" "10"
			sendToLog "lp_swrite_quantum=10 in $i"
		fi
		
		if [ -e "$RD_IDLE_DATA" ]; then
			write "$RD_IDLE_DATA" "10"
			sendToLog "rd_idle_data=10 in $i"
		fi
		
		if [ -e "$RD_IDLE_DATA_FREQ" ]; then
			write "$RD_IDLE_DATA_FREQ" "25"
			sendToLog "rd_idle_data_freq=25 in $i"
		fi
		
		if [ -e "$READ_IDLE" ]; then
			write "$READ_IDLE" "10"
			sendToLog "read_idle=10 in $i"
		fi
		
		if [ -e "$READ_IDLE_FREQ" ]; then
			write "$READ_IDLE_FREQ" "25"
			sendToLog "read_idle_freq=25 in $i"
		fi
		
		if [ -e "$REG_STARV_LIMIT" ]; then
			write "$REG_STARV_LIMIT" "5000"
			sendToLog "reg_starv_limit=5000 in $i"
		fi
		
		if [ -e "$RP_READ_QUANTUM" ]; then
			write "$RP_READ_QUANTUM" "75"
			sendToLog "rp_read_quantum=75 in $i"
		fi
		
		if [ -e "$RP_SWRITE_QUANTUM" ]; then
			write "$RP_SWRITE_QUANTUM" "4"
			sendToLog "rp_swrite_quantum=4 in $i"
		fi
		
		if [ -e "$RP_WRITE_QUANTUM" ]; then
			write "$RP_WRITE_QUANTUM" "4"
			sendToLog "rp_write_quantum=4 in $i"
		fi
	
	# fiops
	elif [ "$scheduler" = "fiops" ]; then
		if [ -e "$ASYNC_SCALE" ]; then
			write "$ASYNC_SCALE" "5"
			sendToLog "async_scale=5 in $i"
		fi
		
		if [ -e "$READ_SCALE" ]; then
			write "$READ_SCALE" "3"
			sendToLog "read_scale=3 in $i"
		fi
		
		if [ -e "$SYNC_SCALE" ]; then
			write "$SYNC_SCALE" "2"
			sendToLog "sync_scale=2 in $i"
		fi
		
		if [ -e "$WRITE_SCALE" ]; then
			write "$WRITE_SCALE" "4"
			sendToLog "write_scale=4 in $i"
		fi
	
	#  sio/sioplus
	elif [ "$scheduler" = "sio" ] || [ "$scheduler" = "sioplus" ]; then
		if [ -e "$ASYNC_READ_EXPIRE" ]; then
			write "$ASYNC_READ_EXPIRE" "500"
			sendToLog "async_read_expire=500 in $i"
		fi
		
		if [ -e "$ASYNC_WRITE_EXPIRE" ]; then
			write "$ASYNC_WRITE_EXPIRE" "1500"
			sendToLog "async_write_expire=1500 in $i"
		fi
		
		if [ -e "$FIFO_BATCH" ]; then
			write "$FIFO_BATCH" "3"
			sendToLog "fifo_batch=3 in $i"
		fi
		
		if [ -e "$SYNC_READ_EXPIRE" ]; then
			write "$SYNC_READ_EXPIRE" "250"
			sendToLog "sync_read_expire=250 in $i"
		fi
		
		if [ -e "$SYNC_WRITE_EXPIRE" ]; then
			write "$SYNC_WRITE_EXPIRE" "1250"
			sendToLog "sync_write_expire=1250 in $i"
		fi
		
		if [ -e "$WRITES_STARVED" ]; then
			write "$WRITES_STARVED" "1"
			sendToLog "writes_starved=1 in $i"
		fi

	# zen
	elif [ "$scheduler" = "zen" ]; then
		if [ -e "$ASYNC_EXPIRE" ]; then
			write "$ASYNC_EXPIRE" "2500"
			sendToLog "async_expire=2500 in $i"
		fi
		
		if [ -e "$FIFO_BATCH" ]; then
			write "$FIFO_BATCH" "8"
			sendToLog "fifo_batch=8 in $i"
		fi
		
		if [ -e "$SYNC_EXPIRE" ]; then
			write "$SYNC_EXPIRE" "300"
			sendToLog "sync_expire=300 in $i"
		fi
		
	else
		if [ "$scheduler" != "none" ]; then
			sendToLog "Scheduler $scheduler in $i is not supported"
		fi
	fi
	
	done
	sendToLog "Scheduler tuner is activated"
	sendToLog "$divider";
}

dnsCloudFlare() {
	sendToLog "Activating CloudFlare DNS..."

	iptables -t nat -A OUTPUT -p tcp --dport 53 -j DNAT --to-destination 1.1.1.1:53
	iptables -t nat -A OUTPUT -p udp --dport 53 -j DNAT --to-destination 1.0.0.1:53
	iptables -t nat -I OUTPUT -p tcp --dport 53 -j DNAT --to-destination 1.1.1.1:53
	iptables -t nat -I OUTPUT -p udp --dport 53 -j DNAT --to-destination 1.0.0.1:53

	sendToLog "CloudFlare DNS is activated"
	sendToLog "$divider";
}

dnsGooglePublic() {
	sendToLog "Activating Google DNS..."

	iptables -t nat -A OUTPUT -p tcp --dport 53 -j DNAT --to-destination 208.67.222.222:53
	iptables -t nat -A OUTPUT -p udp --dport 53 -j DNAT --to-destination 208.67.222.222:53

	sendToLog "Google DNS is activated"
	sendToLog "$divider";
}

dnsOpenDNS() {
	sendToLog "Activating Open DNS..."

	iptables -t nat -A OUTPUT -p tcp --dport 53 -j DNAT --to-destination 8.8.8.8:53
	iptables -t nat -A OUTPUT -p udp --dport 53 -j DNAT --to-destination 8.8.8.8:53

	sendToLog "Open DNS is activated"
	sendToLog "$divider";
}

netBuffersBig() {
	sendToLog "Activating big net buffers..."

	# Define TCP buffer sizes for various networks
	# ReadMin, ReadInitial, ReadMax, WriteMin, WriteInitial, WriteMax
	setprop net.tcp.buffersize.default 6144,87380,1048576,6144,87380,524288
	setprop net.tcp.buffersize.wifi 524288,1048576,2097152,524288,1048576,2097152
	setprop net.tcp.buffersize.umts 6144,87380,1048576,6144,87380,524288
	setprop net.tcp.buffersize.gprs 6144,87380,1048576,6144,87380,524288
	setprop net.tcp.buffersize.edge 6144,87380,524288,6144,16384,262144
	setprop net.tcp.buffersize.hspa 6144,87380,524288,6144,16384,262144
	setprop net.tcp.buffersize.lte 524288,1048576,2097152,524288,1048576,2097152
	setprop net.tcp.buffersize.hsdpa 6144,87380,1048576,6144,87380,1048576
	setprop net.tcp.buffersize.evdo_b 6144,87380,1048576,6144,87380,1048576

	sendToLog "Big net buffers activated"
	sendToLog "$divider";
}

netBuffersSmall() {
	sendToLog "Activating small net buffers..."

	# Define TCP buffer sizes for various networks
	# ReadMin, ReadInitial, ReadMax, WriteMin, WriteInitial, WriteMax
	setprop net.tcp.buffersize.hspa 4096,32768,65536,4096,32768,65536
	setprop net.tcp.buffersize.umts 4096,32768,65536,4096,32768,65536
	setprop net.tcp.buffersize.edge 4096,32768,65536,4096,32768,65536
	setprop net.tcp.buffersize.gprs 4096,32768,65536,4096,32768,65536
	setprop net.tcp.buffersize.hsdpa 4096,32768,65536,4096,32768,65536
	setprop net.tcp.buffersize.wifi 4096,32768,65536,4096,32768,65536
	setprop net.tcp.buffersize.evdo_b 4096,32768,65536,4096,32768,65536
	setprop net.tcp.buffersize.lte 4096,32768,65536,4096,32768,65536
	setprop net.tcp.buffersize.default 4096,32768,12582912,4096,32768,12582912

	sendToLog "Small net buffers activated"
	sendToLog "$divider";
}

netSpeedPlus() {
	sendToLog "Activating Net Speed+..."

	net=$($BUSYBOX ls -d /sys/class/net/*);
	for i in $net; do
		if [ -e "$i"/tx_queue_len ]; then
			write "$i"/tx_queue_len "128"
			sendToLog "tx_queue_len=128 in $i";
		fi
	done

	#for i in $(ls /sys/class/net); do
	#echo "1500" > /sys/class/net/"$i"/mtu
	#echo "mtu=1500 in $i" >> $LOG;
	#done

	sendToLog "Net Speed+ activated"
	sendToLog "$divider";
}

netTcpTweaks() {
	sendToLog "Activating TCP tweak..."

	#echo "128" > /proc/sys/net/core/netdev_max_backlog
	#echo "0" > /proc/sys/net/core/netdev_tstamp_prequeue
	#echo "0" > /proc/sys/net/ipv4/cipso_cache_bucket_size
	#echo "0" > /proc/sys/net/ipv4/cipso_cache_enable
	#echo "0" > /proc/sys/net/ipv4/cipso_rbm_strictvalid
	#echo "0" > /proc/sys/net/ipv4/igmp_link_local_mcast_reports
	#echo "24" > /proc/sys/net/ipv4/ipfrag_time
	#echo "1" > /proc/sys/net/ipv4/tcp_ecn
	#echo "0" > /proc/sys/net/ipv4/tcp_fwmark_accept
	#echo "320" > /proc/sys/net/ipv4/tcp_keepalive_intvl
	#echo "21600" > /proc/sys/net/ipv4/tcp_keepalive_time
	#echo "1" > /proc/sys/net/ipv4/tcp_no_metrics_save
	#echo "1800" > /proc/sys/net/ipv4/tcp_probe_interval
	#echo "0" > /proc/sys/net/ipv4/tcp_slow_start_after_idle
	#echo "48" > /proc/sys/net/ipv6/ip6frag_time

	echo "0" > /proc/sys/net/ipv4/conf/default/secure_redirects
	echo "0" > /proc/sys/net/ipv4/conf/default/accept_redirects
	echo "0" > /proc/sys/net/ipv4/conf/default/accept_source_route
	echo "0" > /proc/sys/net/ipv4/conf/all/secure_redirects
	echo "0" > /proc/sys/net/ipv4/conf/all/accept_redirects
	echo "0" > /proc/sys/net/ipv4/conf/all/accept_source_route
	echo "0" > /proc/sys/net/ipv4/ip_forward
	echo "0" > /proc/sys/net/ipv4/ip_dynaddr
	echo "0" > /proc/sys/net/ipv4/ip_no_pmtu_disc
	echo "0" > /proc/sys/net/ipv4/tcp_ecn
	echo "0" > /proc/sys/net/ipv4/tcp_timestamps
	echo "1" > /proc/sys/net/ipv4/tcp_tw_reuse
	echo "1" > /proc/sys/net/ipv4/tcp_fack
	echo "1" > /proc/sys/net/ipv4/tcp_sack
	echo "1" > /proc/sys/net/ipv4/tcp_dsack
	echo "1" > /proc/sys/net/ipv4/tcp_rfc1337
	echo "1" > /proc/sys/net/ipv4/tcp_tw_recycle
	echo "1" > /proc/sys/net/ipv4/tcp_window_scaling
	echo "1" > /proc/sys/net/ipv4/tcp_moderate_rcvbuf
	echo "1" > /proc/sys/net/ipv4/tcp_no_metrics_save
	echo "2" > /proc/sys/net/ipv4/tcp_synack_retries
	echo "2" > /proc/sys/net/ipv4/tcp_syn_retries
	echo "5" > /proc/sys/net/ipv4/tcp_keepalive_probes
	echo "30" > /proc/sys/net/ipv4/tcp_keepalive_intvl
	echo "30" > /proc/sys/net/ipv4/tcp_fin_timeout
	echo "1800" > /proc/sys/net/ipv4/tcp_keepalive_time
	echo "261120" > /proc/sys/net/core/rmem_max
	echo "261120" > /proc/sys/net/core/wmem_max
	echo "261120" > /proc/sys/net/core/rmem_default
	echo "261120" > /proc/sys/net/core/wmem_default

	sendToLog "TCP tweak activated"
	sendToLog "$divider";
}

rilTweaks() {
	sendToLog "Activating ril tweaks..."

	resetprop ro.ril.gprsclass 12
	sendToLog "GPRS Class changed to 12"

	resetprop ro.ril.hsdpa.category 28
	sendToLog "hsdpa category changed to 28"

	resetprop ro.ril.hsupa.category 7
	sendToLog "hsupa category changed to 7"

	resetprop ro.telephony.call_ring.delay 1500
	sendToLog "RING/CRING event delay reduced to 1.5sec"

	resetprop ro.telephony.call_ring.multiple false
	sendToLog "Ril sends only one RIL_UNSOL_CALL_RING, so set call_ring.multiple to false"

	sendToLog "Ril tweaks are activated"
	sendToLog "$divider";
}

disableDebugging() {
	sendToLog "Powerful logging disable started..."

	$BUSYBOX find /sys -name debug_mask |
	while read -r fileName
		do
			write "$fileName" "0"
			sendToLog "Disabled debugging for $fileName"  
	done

	$BUSYBOX find /sys -name debug |
	while read -r fileName
		do
			write "$fileName" "0"
			sendToLog "Disabled debugging for $fileName"  
	done

	$BUSYBOX find /sys -name debug_enabled |
	while read -r fileName
		do
			write "$fileName" "0"
			sendToLog "Disabled debugging for $fileName"  
	done

	$BUSYBOX find /sys -name debug_level |
	while read -r fileName
		do
			write "$fileName" "0"
			sendToLog "Disabled debugging for $fileName"  
	done

	$BUSYBOX find /sys -name edac_mc_log_ce |
	while read -r fileName
		do
			write "$fileName" "0"
			sendToLog "Disabled debugging for $fileName"  
	done

	$BUSYBOX find /sys -name edac_mc_log_ue |
	while read -r fileName
		do
			write "$fileName" "0"
			sendToLog "Disabled debugging for $fileName"  
	done

	find /sys -name enable_event_log |
	while read -r fileName
		do
			write "$fileName" "0"
			sendToLog "Disabled debugging for $fileName"  
	done

	$BUSYBOX find /sys -name log_ecn_error |
	while read -r fileName
		do
			write "$fileName" "0"
			sendToLog "Disabled debugging for $fileName"  
	done

	$BUSYBOX find /sys -name snapshot_crashdumper |
	while read -r fileName
		do
			write "$fileName" "0"
			sendToLog "Disabled debugging for $fileName"  
	done

	sched_schedstats=/proc/sys/kernel/sched_schedstats
	if [ -e $sched_schedstats ]; then
		write $sched_schedstats "0"
		sendToLog "Disabled sched_schedstats"
	fi;

	console_suspend=/sys/module/printk/parameters/console_suspend
	if [ -e $console_suspend ]; then
		write $console_suspend "Y"
		sendToLog "Console suspended"
	fi;

	log_mode=/sys/module/logger/parameters/log_mode
	if [ -e $log_mode ]; then
		write $log_mode "2"
		sendToLog "Logger disabled"
	fi;

	debug_enabled=/sys/kernel/debug/debug_enabled
	if [ -e $debug_enabled ]; then
		write $debug_enabled "N"
		sendToLog "Disabled kernel debugging"
	fi;

	exception_trace=/proc/sys/debug/exception-trace
	if [ -e "$exception_trace" ]; then
		write $exception_trace "0"
		sendToLog "Disabled exception-trace debugger"
	fi;

	mali_debug_level=/sys/module/mali/parameters/mali_debug_level
	if [ -e $mali_debug_level ]; then
		write $mali_debug_level "0"
		sendToLog "Disabled mali GPU debugging"
	fi;

	block_dump=/proc/sys/vm/block_dump
	if [ -e $block_dump ]; then
		write $block_dump "0"
		sendToLog "Disabled I/O block debugging"
	fi;

	mballoc_debug=/sys/module/ext4/parameters/mballoc_debug
	if [ -e $mballoc_debug ]; then
		write $mballoc_debug "0"
		sendToLog "Disabled ext4 runtime debugging"
	fi;

	logger_mode=/sys/kernel/logger_mode/logger_mode
	if [ -e $logger_mode ]; then
		write $logger_mode "0"
		sendToLog "Disabled $logger_mode"
	fi;

	log_enabled=/sys/module/logger/parameters/log_enabled
	if [ -e $log_enabled ]; then
		write $log_enabled "0"
		sendToLog "Disabled $log_enabled"
	fi;

	logger_enabled=/sys/module/logger/parameters/enabled
	if [ -e $logger_enabled ]; then
		write $logger_enabled "0"
		sendToLog "Disabled $logger_enabled"
	fi;

	compat_log=/proc/sys/kernel/compat-log
	if [ -e $compat_log ]; then
		write $compat_log "0"
		sendToLog "Compat logging disabled"
	fi;

	disable_ertm=/sys/module/bluetooth/parameters/disable_ertm
	if [ -e $disable_ertm ]; then
		write $disable_ertm "0"
		sendToLog "Bluetooth ertm disabled"
	fi;

	disable_esco=/sys/module/bluetooth/parameters/disable_esco
	if [ -e $disable_esco ]; then
		write $disable_esco "0"
		sendToLog "Bluetooth esco is disabled"
	fi;

	sendToLog "Logging disabled..."
	sendToLog "$divider";
}

disableKernelPanic() {
sendToLog "Disabling kernel panic..."

	$BUSYBOX sysctl -e -w vm.panic_on_oom=0
	$BUSYBOX sysctl -e -w kernel.panic_on_oops=0
	$BUSYBOX sysctl -e -w kernel.panic=0
	$BUSYBOX sysctl -e -w kernel.panic_on_warn=0

sendToLog "Kernel panic disabled"
sendToLog "$divider";
}

selinux() {
	sendToLog "Changing selinux..."

	setenforce $1
	
	selinuxState=$(cat /sys/fs/selinux/enforce)

	if [ $1 -eq $selinuxState ]; then
		if [ $selinuxState -eq 0 ]; then
			sendToLog "Selinux changed to permissive"
		elif [ $selinuxState -eq 1 ]; then
			sendToLog "Selinux changed to enforcing"
		fi
	else
		sendToLog "Unable to change selinux mode"
	fi

	sendToLog "$divider"
}

disableMultitaskingLimitations() {
	sendToLog "Disabling multitasking limitations..."

	setprop MIN_HIDDEN_APPS false
	sendToLog "MIN_HIDDEN_APPS=false"

	setprop ACTIVITY_INACTIVE_RESET_TIME false
	sendToLog "ACTIVITY_INACTIVE_RESET_TIME=false"

	setprop MIN_RECENT_TASKS false
	sendToLog "MIN_RECENT_TASKS=false"

	setprop PROC_START_TIMEOUT false
	sendToLog "PROC_START_TIMEOUT=false"

	setprop CPU_MIN_CHECK_DURATION false
	sendToLog "CPU_MIN_CHECK_DURATION=false"

	setprop GC_TIMEOUT false
	sendToLog "GC_TIMEOUT=false"

	setprop SERVICE_TIMEOUT false
	sendToLog "SERVICE_TIMEOUT=false"

	setprop MIN_CRASH_INTERVAL false
	sendToLog "MIN_CRASH_INTERVAL=false"

	setprop ENFORCE_PROCESS_LIMIT false
	sendToLog "ENFORCE_PROCESS_LIMIT=false"

	sendToLog "Multitasking limitations disabled"
	sendToLog "$divider";
}

lowRamFlagDisabled() {
	sendToLog "Disabling low RAM flag..."

	resetprop ro.config.low_ram false

	sendToLog "Low RAM flag disabled"
	sendToLog "$divider";
}

lowRamFlagEnabled() {
	sendToLog "Enabling low RAM flag..."

	resetprop ro.config.low_ram true

	sendToLog "Low RAM flag enabled"
	sendToLog "$divider";
}

oomKillerDisabled() {
	sendToLog "Disabled OOM killer..."

	oom_kill_allocating_task=/proc/sys/vm/oom_kill_allocating_task
	if [ -e $oom_kill_allocating_task ]; then
		write $oom_kill_allocating_task "0"
	fi;

	sendToLog "OOM killer disabled"
	sendToLog "$divider";
}

oomKillerEnabled() {
	sendToLog "Enabling OOM killer..."

	oom_kill_allocating_task=/proc/sys/vm/oom_kill_allocating_task
	if [ -e $oom_kill_allocating_task ]; then
		write $oom_kill_allocating_task "1"
	fi;

	sendToLog "OOM killer enabled"
	sendToLog "$divider";
}

ramManagerBalanced() {

fa=$(((memTotal*5/2/100)*1024/4));
va=$(((memTotal*3/100)*1024/4));
ss=$(((memTotal*5/100)*1024/4));
ha=$(((memTotal*7/100)*1024/4));
cp=$(((memTotal*9/100)*1024/4));
ea=$(((memTotal*11/100)*1024/4));
minFree="$fa,$va,$ss,$ha,$cp,$ea";

# Higher values of oom_adj are more likely
# to be killed by the kernel's oom killer.
# The current foreground app has a oom_adj of 0
adj="0,112,224,408,824,1000";

# If you set this to lower than 1024KB, your system will
# become subtly broken, and prone to deadlock under high loads, we don't allow it below 3072kb
mfk=$((memTotal*9/5));

if [ "$mfk" -le "3072" ]; then
mfk=3072;
fi;

# Extra free kbytes calculated based on min_free_kbytes
efk=$((mfk*16/5));

if [ "$efk" -le 18432 ]; then
	efk=18432‬;
fi;

# Background app limit per ram size
if [ "$memTotal" -le "1024" ]; then
	backgroundAppLimit="24";
elif [ "$memTotal" -le "2048" ]; then
	backgroundAppLimit="28";
elif [ "$memTotal" -le "3072" ]; then
	backgroundAppLimit="30";
elif [ "$memTotal" -le "4096" ]; then
	backgroundAppLimit="36";
else
	backgroundAppLimit="42";
fi;

# Set 1 to reclaim resources quickly when needed.
fastRun="0";

oomReaper="1";
adaptiveLmk="0";

# How much memory of swap will be counted as free
fudgeSwap="1024";


sendToLog "Enabling balanced RAM manager profile"

sync
$BUSYBOX sysctl -w vm.drop_caches=3;

resetprop ro.sys.fw.bg_apps_limit $backgroundAppLimit;
resetprop ro.vendor.qti.sys.fw.bg_apps_limit $backgroundAppLimit;
sendToLog "Background app limit=$backgroundAppLimit"

parameter_adj=/sys/module/lowmemorykiller/parameters/adj;
if [ -e $parameter_adj ]; then
	write $parameter_adj "$adj"
	sendToLog "adj=$adj"
fi;

parameter_oom_reaper=/sys/module/lowmemorykiller/parameters/oom_reaper;
if [ -e $parameter_oom_reaper ]; then
	write $parameter_oom_reaper "$oomReaper"
	sendToLog "oom_reaper=$oomReaper"
fi;

parameter_lmk_fast_run=/sys/module/lowmemorykiller/parameters/lmk_fast_run;
if [ -e $parameter_lmk_fast_run ]; then
	write $parameter_lmk_fast_run "$fastRun"
	sendToLog "lmk_fast_run=$fastRun"
fi;

parameter_adaptive_lmk=/sys/module/lowmemorykiller/parameters/enable_adaptive_lmk;
if [ -e $parameter_adaptive_lmk ]; then
	write $parameter_adaptive_lmk "$adaptiveLmk"
	setprop lmk.autocalc false;
	sendToLog "adaptive_lmk=$adaptiveLmk"
fi;

parameter_fudge_swap=/sys/module/lowmemorykiller/parameters/fudgeswap;
if [ -e $parameter_fudge_swap ]; then
	write $parameter_fudge_swap "$fudgeSwap"
	sendToLog "fudge_swap=$fudgeSwap"
fi;

parameter_minfree=/sys/module/lowmemorykiller/parameters/minfree;
if [ -e $parameter_minfree ]; then
	write $parameter_minfree "$minFree"
	sendToLog "minfree=$minFree"
fi;

parameter_min_free_kbytes=/proc/sys/vm/min_free_kbytes;
if [ -e $parameter_min_free_kbytes ]; then
	write $parameter_min_free_kbytes "$mfk"
	sendToLog "min_free_kbytes=$mfk"
fi;

parameter_extra_free_kbytes=/proc/sys/vm/extra_free_kbytes;
if [ -e $parameter_extra_free_kbytes ]; then
	write $parameter_extra_free_kbytes "$efk"
	sendToLog "extra_free_kbytes=$efk"
fi;

sendToLog "Balanced RAM manager profile for $((memTotal))mb devices successfully applied"
sendToLog "$divider";
}

ramManagerGaming() {

fa=$(((memTotal*3/2/100)*1024/4));
va=$(((memTotal*2/100)*1024/4));
ss=$(((memTotal*4/100)*1024/4));
ha=$(((memTotal*7/100)*1024/4));
cp=$(((memTotal*11/100)*1024/4));
ea=$(((memTotal*15/100)*1024/4));
minFree="$fa,$va,$ss,$ha,$cp,$ea";

# Higher values of oom_adj are more likely
# to be killed by the kernel's oom killer.
# The current foreground app has a oom_adj of 0
adj="0,112,224,408,824,1000";

# If you set this to lower than 1024KB, your system will
# become subtly broken, and prone to deadlock under high loads, we don't allow it below 3072kb
mfk=$((memTotal*9/5));

if [ "$mfk" -le "3072" ]; then
mfk=3072;
fi;

# Extra free kbytes calculated based on min_free_kbytes
efk=$((mfk*16/5));

if [ "$efk" -le 18432 ]; then
	efk=18432‬;
fi;

# Background app limit per ram size
if [ "$memTotal" -le "1024" ]; then
	backgroundAppLimit="18";
elif [ "$memTotal" -le "2048" ]; then
	backgroundAppLimit="22";
elif [ "$memTotal" -le "3072" ]; then
	backgroundAppLimit="26";
elif [ "$memTotal" -le "4096" ]; then
	backgroundAppLimit="30";
else
	backgroundAppLimit="42";
fi;

# Set 1 to reclaim resources quickly when needed.
fastRun="1";

oomReaper="1";
adaptiveLmk="0";

# How much memory of swap will be counted as free
fudgeSwap="1024";


sendToLog "Enabling gaming RAM manager profile"

sync
$BUSYBOX sysctl -w vm.drop_caches=3;

resetprop ro.sys.fw.bg_apps_limit $backgroundAppLimit;
resetprop ro.vendor.qti.sys.fw.bg_apps_limit $backgroundAppLimit;
sendToLog "Background app limit=$backgroundAppLimit"

parameter_adj=/sys/module/lowmemorykiller/parameters/adj;
if [ -e $parameter_adj ]; then
	write $parameter_adj "$adj"
	sendToLog "adj=$adj"
fi;

parameter_oom_reaper=/sys/module/lowmemorykiller/parameters/oom_reaper;
if [ -e $parameter_oom_reaper ]; then
	write $parameter_oom_reaper "$oomReaper"
	sendToLog "oom_reaper=$oomReaper"
fi;

parameter_lmk_fast_run=/sys/module/lowmemorykiller/parameters/lmk_fast_run;
if [ -e $parameter_lmk_fast_run ]; then
	write $parameter_lmk_fast_run "$fastRun"
	sendToLog "lmk_fast_run=$fastRun"
fi;

parameter_adaptive_lmk=/sys/module/lowmemorykiller/parameters/enable_adaptive_lmk;
if [ -e $parameter_adaptive_lmk ]; then
	write $parameter_adaptive_lmk "$adaptiveLmk"
	setprop lmk.autocalc false;
	sendToLog "adaptive_lmk=$adaptiveLmk"
fi;

parameter_fudge_swap=/sys/module/lowmemorykiller/parameters/fudgeswap;
if [ -e $parameter_fudge_swap ]; then
	write $parameter_fudge_swap "$fudgeSwap"
	sendToLog "fudge_swap=$fudgeSwap"
fi;

parameter_minfree=/sys/module/lowmemorykiller/parameters/minfree;
if [ -e $parameter_minfree ]; then
	write $parameter_minfree "$minFree"
	sendToLog "minfree=$minFree"
fi;

parameter_min_free_kbytes=/proc/sys/vm/min_free_kbytes;
if [ -e $parameter_min_free_kbytes ]; then
	write $parameter_min_free_kbytes "$mfk"
	sendToLog "min_free_kbytes=$mfk"
fi;

parameter_extra_free_kbytes=/proc/sys/vm/extra_free_kbytes;
if [ -e $parameter_extra_free_kbytes ]; then
	write $parameter_extra_free_kbytes "$efk"
	sendToLog "extra_free_kbytes=$efk"
fi;

sendToLog "Gaming RAM manager profile for $((memTotal))mb devices successfully applied"
sendToLog "$divider";
}

ramManagerMultitasking() {

fa=$(((memTotal*2/100)*1024/4));
va=$(((memTotal*3/100)*1024/4));
ss=$(((memTotal*4/100)*1024/4));
ha=$(((memTotal*6/100)*1024/4));
cp=$(((memTotal*9/100)*1024/4));
ea=$(((memTotal*12/100)*1024/4));
minFree="$fa,$va,$ss,$ha,$cp,$ea";

# Higher values of oom_adj are more likely
# to be killed by the kernel's oom killer.
# The current foreground app has a oom_adj of 0
adj="0,112,224,408,824,1000";

# If you set this to lower than 1024KB, your system will
# become subtly broken, and prone to deadlock under high loads, we don't allow it below 3072kb
mfk=$((memTotal*9/5));

if [ "$mfk" -le "3072" ]; then
mfk=3072;
fi;

# Extra free kbytes calculated based on min_free_kbytes
efk=$((mfk*16/5));

if [ "$efk" -le 18432 ]; then
	efk=18432‬;
fi;

# Background app limit per ram size
if [ "$memTotal" -le "1024" ]; then
	backgroundAppLimit="25";
elif [ "$memTotal" -le "2048" ]; then
	backgroundAppLimit="30";
elif [ "$memTotal" -le "3072" ]; then
	backgroundAppLimit="36";
elif [ "$memTotal" -le "4096" ]; then
	backgroundAppLimit="42";
else
	backgroundAppLimit="44";
fi;

# Set 1 to reclaim resources quickly when needed.
fastRun="0";

oomReaper="1";
adaptiveLmk="0";

# How much memory of swap will be counted as free
fudgeSwap="1024";


sendToLog "Enabling multitasking RAM manager profile"

sync
$BUSYBOX sysctl -w vm.drop_caches=3;

resetprop ro.sys.fw.bg_apps_limit $backgroundAppLimit;
resetprop ro.vendor.qti.sys.fw.bg_apps_limit $backgroundAppLimit;
sendToLog "Background app limit=$backgroundAppLimit"

parameter_adj=/sys/module/lowmemorykiller/parameters/adj;
if [ -e $parameter_adj ]; then
	write $parameter_adj "$adj"
	sendToLog "adj=$adj"
fi;

parameter_oom_reaper=/sys/module/lowmemorykiller/parameters/oom_reaper;
if [ -e $parameter_oom_reaper ]; then
	write $parameter_oom_reaper "$oomReaper"
	sendToLog "oom_reaper=$oomReaper"
fi;

parameter_lmk_fast_run=/sys/module/lowmemorykiller/parameters/lmk_fast_run;
if [ -e $parameter_lmk_fast_run ]; then
	write $parameter_lmk_fast_run "$fastRun"
	sendToLog "lmk_fast_run=$fastRun"
fi;

parameter_adaptive_lmk=/sys/module/lowmemorykiller/parameters/enable_adaptive_lmk;
if [ -e $parameter_adaptive_lmk ]; then
	write $parameter_adaptive_lmk "$adaptiveLmk"
	setprop lmk.autocalc false;
	sendToLog "adaptive_lmk=$adaptiveLmk"
fi;

parameter_fudge_swap=/sys/module/lowmemorykiller/parameters/fudgeswap;
if [ -e $parameter_fudge_swap ]; then
	write $parameter_fudge_swap "$fudgeSwap"
	sendToLog "fudge_swap=$fudgeSwap"
fi;

parameter_minfree=/sys/module/lowmemorykiller/parameters/minfree;
if [ -e $parameter_minfree ]; then
	write $parameter_minfree "$minFree"
	sendToLog "minfree=$minFree"
fi;

parameter_min_free_kbytes=/proc/sys/vm/min_free_kbytes;
if [ -e $parameter_min_free_kbytes ]; then
	write $parameter_min_free_kbytes "$mfk"
	sendToLog "min_free_kbytes=$mfk"
fi;

parameter_extra_free_kbytes=/proc/sys/vm/extra_free_kbytes;
if [ -e $parameter_extra_free_kbytes ]; then
	write $parameter_extra_free_kbytes "$efk"
	sendToLog "extra_free_kbytes=$efk"
fi;

sendToLog "Multitasking RAM manager profile for $((memTotal))mb devices successfully applied"
sendToLog "$divider";
}

swappinessTendency() {
	sendToLog "Setting swappiness tendency...";

	swappiness=/proc/sys/vm/swappiness
	if [ -e $swappiness ]; then
		if [ "$1" = "1" ]; then
			write $swappiness "1"
			
			sendToLog "swappiness=1";
			sendToLog "Swappiness tendency set to 1";
		elif [ "$1" = "2" ]; then
			write $swappiness "10"
			
			sendToLog "swappiness=10";
			sendToLog "Swappiness tendency set to 10";
			
		elif [ "$1" = "3" ]; then
			write $swappiness "25"
			
			sendToLog "swappiness=25";
			sendToLog "Swappiness tendency set to 25";
			
		elif [ "$1" = "4" ]; then
			write $swappiness "50"
			
			sendToLog "swappiness=50";
			sendToLog "Swappiness tendency set to 50";

		elif [ "$1" = "5" ]; then
			write $swappiness "75"
			
			sendToLog "swappiness=75";
			sendToLog "Swappiness tendency set to 75";

		elif [ "$1" = "6" ]; then
			write $swappiness "100"
			
			sendToLog "swappiness=100";
			sendToLog "Swappiness tendency set to 100";			
		fi
	fi;
	sendToLog "$divider";
}

virtualMemoryTweaks() {
	if [ "$1" = "1" ]; then
		profile="battery"
	elif [ "$1" = "2" ]; then
		profile="balanced"
	elif [ "$1" = "3" ]; then
		profile="performance"
	fi

	sendToLog "Activating $profile virtual memory tweaks..."

	sync

	leases_enable=/proc/sys/fs/leases-enable
	if [ -e $leases_enable ]; then
		write $leases_enable "1"		
		sendToLog "leases_enable=1"
	fi;

	# This file specifies the grace period (in seconds) that the kernel grants
	# to a process holding a file lease after it has sent a signal to that process
	# notifying it that another process is waiting to open the file.
	# If the lease holder does not remove or downgrade the lease within this grace period,
	# the kernel forcibly breaks the lease.

	lease_break_time=/proc/sys/fs/lease-break-time
	if [ -e $lease_break_time ]; then
		write $lease_break_time "20"		
		sendToLog "lease_break_time=20"
	fi;

	# dnotify is a signal used to notify a process about file/directory changes.
	dir_notify_enable=/proc/sys/fs/dir-notify-enable
	if [ -e $dir_notify_enable ]; then
		write $dir_notify_enable "0"		
		sendToLog "dir_notify_enable=0"
	fi;

	sendToLog "File system parameters are updated"

	enable_process_reclaim=/sys/module/process_reclaim/parameters/enable_process_reclaim
	if [ -e $enable_process_reclaim ]; then
		write $enable_process_reclaim "0"		
		sendToLog "Reclaiming pages of inactive tasks disabled"
	fi;

	# This parameter tells how much of physical RAM to take when swap is full
	overcommit_ratio=/proc/sys/vm/overcommit_ratio
	if [ -e overcommit_ratio ]; then
		write $overcommit_ratio "25"		
		sendToLog "overcommit_ratio=25"
	fi;

	oom_dump_tasks=/proc/sys/vm/oom_dump_tasks
	if [ -e $oom_dump_tasks ]; then
		write $oom_dump_tasks "0"		
		sendToLog "OOM dump tasks are disabled"
	fi;

	vfs_cache_pressure=/proc/sys/vm/vfs_cache_pressure
	if [ -e $vfs_cache_pressure ]; then
		if [ "$1" = "1" ]; then
			write $vfs_cache_pressure "20"		
			sendToLog "vfs_cache_pressure=20"
		elif [ "$1" = "2" ]; then
			write $vfs_cache_pressure "75"		
			sendToLog "vfs_cache_pressure=75"
		elif [ "$1" = "3" ]; then
			write $vfs_cache_pressure "100"		
			sendToLog "vfs_cache_pressure=100"
		fi
	fi

	laptop_mode=/proc/sys/vm/laptop_mode
	if [ -e $laptop_mode ]; then
		write $laptop_mode "0"		
		sendToLog "laptop_mode=0"
	fi;

	# page-cluster controls the number of pages up to which consecutive pages
	# are read in from swap in a single attempt. This is the swap counterpart
	# to page cache readahead.
	# The mentioned consecutivity is not in terms of virtual/physical addresses,
	# but consecutive on swap space - that means they were swapped out together.
	# It is a logarithmic value - setting it to zero means "1 page", setting
	# it to 1 means "2 pages", setting it to 2 means "4 pages", etc.
	# Zero disables swap readahead completely.
	# The default value is three (eight pages at a time).  There may be some
	# small benefits in tuning this to a different value if your workload is
	# swap-intensive.
	# Lower values mean lower latencies for initial faults, but at the same time
	# extra faults and I/O delays for following faults if they would have been part of
	# that consecutive pages readahead would have brought in.
	page_cluster=/proc/sys/vm/page-cluster
	if [ -e $page_cluster ]; then
		write $page_cluster "0"		
		sendToLog "page_cluster=0"
	fi;

	# vm.dirty_expire_centisecs is how long something can be in cache
	# before it needs to be written.
	# When the pdflush/flush/kdmflush processes kick in they will
	# check to see how old a dirty page is, and if it’s older than this value it’ll
	# be written asynchronously to disk. Since holding a dirty page in memory is
	# unsafe this is also a safeguard against data loss.
	dirty_expire_centisecs=/proc/sys/vm/dirty_expire_centisecs
	if [ -e $dirty_expire_centisecs ]; then
		if [ "$1" = "1" ]; then
			write $dirty_expire_centisecs "500"		
			sendToLog "dirty_expire_centisecs=500"
		elif [ "$1" = "2" ]; then
			write $dirty_expire_centisecs "250"		
			sendToLog "dirty_expire_centisecs=250"
		elif [ "$1" = "3" ]; then
			write $dirty_expire_centisecs "250"		
			sendToLog "dirty_expire_centisecs=250"
		fi
	fi;

	# vm.dirty_writeback_centisecs is how often the pdflush/flush/kdmflush processes wake up
	# and check to see if work needs to be done.
	dirty_writeback_centisecs=/proc/sys/vm/dirty_writeback_centisecs
	if [ -e $dirty_writeback_centisecs ]; then
		if [ "$1" = "1" ]; then
			write $dirty_writeback_centisecs "5000"		
			sendToLog "dirty_writeback_centisecs=5000"
		elif [ "$1" = "2" ]; then
			write $dirty_writeback_centisecs "3000"		
			sendToLog "dirty_writeback_centisecs=3000"
		elif [ "$1" = "3" ]; then
			write $dirty_writeback_centisecs "750"		
			sendToLog "dirty_writeback_centisecs=750"
		fi
	fi

	# vm.dirty_background_ratio is the percentage of system memory(RAM)
	# that can be filled with “dirty” pages — memory pages that
	# still need to be written to disk — before the pdflush/flush/kdmflush
	# background processes kick in to write it to disk.
	# It can be 50% or less of dirtyRatio
	# If ( dirty_background_ratio >= dirty_ratio ) {
	# dirty_background_ratio = dirty_ratio / 2 (or 4)
	dirty_background_ratio=/proc/sys/vm/dirty_background_ratio
	if [ -e $dirty_background_ratio ]; then
		if [ "$1" = "1" ]; then
			write $dirty_background_ratio "10"		
			sendToLog "dirty_background_ratio=10"
		elif [ "$1" = "2" ]; then
			write $dirty_background_ratio "5"		
			sendToLog "dirty_background_ratio=5"
		elif [ "$1" = "3" ]; then
			write $dirty_background_ratio "2"		
			sendToLog "dirty_background_ratio=2"
		fi
	fi

	# vm.dirty_ratio is the absolute maximum amount of system memory
	# that can be filled with dirty pages before everything must get committed to disk.
	# When the system gets to this point all new I/O blocks until dirty pages
	# have been written to disk. This is often the source of long I/O pauses,
	# but is a safeguard against too much data being cached unsafely in memory.
	dirty_ratio=/proc/sys/vm/dirty_ratio
	if [ -e $dirty_ratio ]; then
		if [ "$1" = "1" ]; then
			write $dirty_ratio "20"		
			sendToLog "dirty_ratio=20"
		elif [ "$1" = "2" ]; then
			write $dirty_ratio "20"		
			sendToLog "dirty_ratio=20"
		elif [ "$1" = "3" ]; then
			write $dirty_ratio "10"		
			sendToLog "dirty_ratio=10"
		fi
	fi

	sendToLog "Virtual memory tweaks successfully applied $profile profile"
	sendToLog "$divider";
}

heapOptimization() {
	heapSize=$((memTotal*3/16));

	# Don't use more than 512mb
	if [ "$heapSize" -gt "512" ]; then
		heapSize=512;
	fi

	heapGrowthLimit=$((heapSize*5/11));

	sendToLog "Activating heap optimization";

	# The ideal ratio of live to free memory. It's good to have a value between 0.2 and 0.9.
	# This limit the managed hepSize to heapsize*heaptargetutilization so it won't be full every time
	setprop dalvik.vm.heaptargetutilization 0.80
	sendToLog "heapTargetUtilization=0.80";

	# This is the heap size that Dalvik/ART assigns to every new ‘large’ App.
	# Large Apps are the ones that include the ‘android:largeHeap’ option in their manifest.
	# Note that many apps abuse this option, in an effort to increase their performance.
	setprop dalvik.vm.heapsize "$((heapSize))m"
	sendToLog "heapSize=$((heapSize))m";

	# This is the heap size that is assigned to standard Apps.
	# This should typically be no more than half the dalvik.vm.heapsize value.
	setprop dalvik.vm.heapgrowthlimit "$((heapGrowthLimit))m"
	sendToLog "heapgrowthlimit=$((heapGrowthLimit))m";

	# Forces the free memory to never be larger than the given value.
	setprop dalvik.vm.heapmaxfree 8m
	sendToLog "heapmaxfree=8m";

	# Forces the free memory to never be smaller than the given value.
	setprop dalvik.vm.heapminfree 2m
	sendToLog "heapminfree=2m";

	sendToLog "Heap optimization for $((memTotal))mb device activated";
	sendToLog "$divider";
}

#
# Profile presets
#
setDefaultProfile() {
	write "$USER_PROFILE"/battery_improvements "1"
	write "$USER_PROFILE"/doze_optimization "1"

	# CPU section
	write "$USER_PROFILE"/cpu_optimization "0"
	write "$USER_PROFILE"/governor_tuner "0"

	# Entropy section
	write "$USER_PROFILE"/entropy "1"

	# GPU section
	write "$USER_PROFILE"/gpu_optimizer "0"
	write "$USER_PROFILE"/optimize_buffers "0"
	write "$USER_PROFILE"/render_opengles_using_gpu "0"
	write "$USER_PROFILE"/use_opengl_skia "0"
	write "$USER_PROFILE"/force_gpu_rendering "0"
	write "$USER_PROFILE"/force_4x_msaa "0"
	
	# I/O tweaks section
	write "$USER_PROFILE"/disable_io_stats "1"
	write "$USER_PROFILE"/io_blocks_optimization "0"
	write "$USER_PROFILE"/io_extended_queue "0"
	write "$USER_PROFILE"/scheduler_tuner "0"

	# LNET tweaks section
	write "$USER_PROFILE"/dns "0"
	write "$USER_PROFILE"/net_buffers "0"
	write "$USER_PROFILE"/net_speed_plus "0"
	write "$USER_PROFILE"/net_tcp "0"
	write "$USER_PROFILE"/optimize_ril "0"

	# Other
	write "$USER_PROFILE"/disable_debugging "1"
	write "$USER_PROFILE"/disable_kernel_panic "0"

	# RAM manager section
	write "$USER_PROFILE"/ram_manager "2"
	write "$USER_PROFILE"/disable_multitasking_limitations "0"
	write "$USER_PROFILE"/low_ram_flag "-1"
	write "$USER_PROFILE"/oom_killer "-1"
	write "$USER_PROFILE"/swappiness "1"
	write "$USER_PROFILE"/virtual_memory "1"
	write "$USER_PROFILE"/heap_optimization "0"
}

setPowerSavingProfile() {
	write "$USER_PROFILE"/battery_improvements "1"
	write "$USER_PROFILE"/doze_optimization "1"

	# CPU section
	write "$USER_PROFILE"/cpu_optimization "1"
	write "$USER_PROFILE"/governor_tuner "1"

	# Entropy section
	write "$USER_PROFILE"/entropy "1"

	# GPU section
	write "$USER_PROFILE"/gpu_optimizer "1"
	write "$USER_PROFILE"/optimize_buffers "0"
	write "$USER_PROFILE"/render_opengles_using_gpu "0"
	write "$USER_PROFILE"/use_opengl_skia "0"
	write "$USER_PROFILE"/force_gpu_rendering "0"
	write "$USER_PROFILE"/force_4x_msaa "0"
	
	# I/O tweaks section
	write "$USER_PROFILE"/disable_io_stats "1"
	write "$USER_PROFILE"/io_blocks_optimization "1"
	write "$USER_PROFILE"/io_extended_queue "0"
	write "$USER_PROFILE"/scheduler_tuner "1"

	# LNET tweaks section
	write "$USER_PROFILE"/dns "0"
	write "$USER_PROFILE"/net_buffers "0"
	write "$USER_PROFILE"/net_speed_plus "0"
	write "$USER_PROFILE"/net_tcp "0"
	write "$USER_PROFILE"/optimize_ril "0"

	# Other
	write "$USER_PROFILE"/disable_debugging "0"
	write "$USER_PROFILE"/disable_kernel_panic "0"

	# RAM manager section
	write "$USER_PROFILE"/ram_manager "2"
	write "$USER_PROFILE"/disable_multitasking_limitations "0"
	write "$USER_PROFILE"/low_ram_flag "-1"
	write "$USER_PROFILE"/oom_killer "-1"
	write "$USER_PROFILE"/swappiness "1"
	write "$USER_PROFILE"/virtual_memory "1"
	write "$USER_PROFILE"/heap_optimization "0"
}

setBalancedProfile() {
	write "$USER_PROFILE"/battery_improvements "1"
	write "$USER_PROFILE"/doze_optimization "1"

	# CPU section
	write "$USER_PROFILE"/cpu_optimization "2"
	write "$USER_PROFILE"/governor_tuner "2"

	# Entropy section
	write "$USER_PROFILE"/entropy "1"

	# GPU section
	write "$USER_PROFILE"/gpu_optimizer "2"
	write "$USER_PROFILE"/optimize_buffers "0"
	write "$USER_PROFILE"/render_opengles_using_gpu "0"
	write "$USER_PROFILE"/use_opengl_skia "0"
	write "$USER_PROFILE"/force_gpu_rendering "0"
	write "$USER_PROFILE"/force_4x_msaa "0"

	# I/O tweaks section
	write "$USER_PROFILE"/disable_io_stats "1"
	write "$USER_PROFILE"/io_blocks_optimization "2"
	write "$USER_PROFILE"/io_extended_queue "0"
	write "$USER_PROFILE"/scheduler_tuner "1"

	# LNET tweaks section
	write "$USER_PROFILE"/dns "0"
	write "$USER_PROFILE"/net_buffers "0"
	write "$USER_PROFILE"/net_speed_plus "0"
	write "$USER_PROFILE"/net_tcp "1"
	write "$USER_PROFILE"/optimize_ril "1"

	# Other
	write "$USER_PROFILE"/disable_debugging "0"
	write "$USER_PROFILE"/disable_kernel_panic "0"

	# RAM manager section
	write "$USER_PROFILE"/ram_manager "2"
	write "$USER_PROFILE"/disable_multitasking_limitations "0"
	write "$USER_PROFILE"/low_ram_flag "-1"
	write "$USER_PROFILE"/oom_killer "-1"
	write "$USER_PROFILE"/swappiness "1"
	write "$USER_PROFILE"/virtual_memory "2"
	write "$USER_PROFILE"/heap_optimization "0"
}

setPerformanceProfile() {
	write "$USER_PROFILE"/battery_improvements "1"
	write "$USER_PROFILE"/doze_optimization "1"

	# CPU section
	write "$USER_PROFILE"/cpu_optimization "3"
	write "$USER_PROFILE"/governor_tuner "3"

	# Entropy section
	write "$USER_PROFILE"/entropy "1"

	# GPU section
	write "$USER_PROFILE"/gpu_optimizer "3"
	write "$USER_PROFILE"/optimize_buffers "0"
	write "$USER_PROFILE"/render_opengles_using_gpu "0"
	write "$USER_PROFILE"/use_opengl_skia "0"
	write "$USER_PROFILE"/force_gpu_rendering "0"
	write "$USER_PROFILE"/force_4x_msaa "0"

	# I/O tweaks section
	write "$USER_PROFILE"/disable_io_stats "-1"
	write "$USER_PROFILE"/io_blocks_optimization "3"
	write "$USER_PROFILE"/io_extended_queue "0"
	write "$USER_PROFILE"/scheduler_tuner "1"

	# LNET tweaks section
	write "$USER_PROFILE"/dns "0"
	write "$USER_PROFILE"/net_buffers "0"
	write "$USER_PROFILE"/net_speed_plus "1"
	write "$USER_PROFILE"/net_tcp "1"
	write "$USER_PROFILE"/optimize_ril "1"

	# Other
	write "$USER_PROFILE"/disable_debugging "1"
	write "$USER_PROFILE"/disable_kernel_panic "0"

	# RAM manager section
	write "$USER_PROFILE"/ram_manager "3"
	write "$USER_PROFILE"/disable_multitasking_limitations "0"
	write "$USER_PROFILE"/low_ram_flag "-1"
	write "$USER_PROFILE"/oom_killer "-1"
	write "$USER_PROFILE"/swappiness "1"
	write "$USER_PROFILE"/virtual_memory "3"
	write "$USER_PROFILE"/heap_optimization "0"
}

# Check number of arguments and perform task based on it.
if [ "$#" -eq 2 ]; then
	$BUSYBOX sleep 0.5;
	"$1" "$2";
	
	exit 0;
elif [ "$#" -eq 1 ]; then
	$BUSYBOX sleep 0.5;
	"$1"
	
	exit 0;
else
sendToLog "Starting L Speed";

# Wait for boot completed and then continue with execution, when getprop sys.boot_completed is	
# equal to 1 while loop will be passed	
attempts=40	
wait=5 # Time in seconds	
bootCompleted=false	
while [ "$attempts" -gt 0 ] && [ "$(getprop sys.boot_completed)" != "1" ]; do	
   sendToLog "Waiting for boot_completed"	
   $BUSYBOX sleep $wait	
   bootCompleted=true	
   attempts=$((attempts-1))	
done	

if [ "$bootCompleted" = true ]; then	
	sendToLog "Waiting for 1min 30secs before applying"	
	$BUSYBOX sleep 90;	
fi

# Read current profile
currentProfile=$($BUSYBOX cat "$PROFILE" 2>/dev/null);
sendToLog "Getting profile...";

if [ "$currentProfile" = "-1" ]; then
	profile="user defined";

elif [ "$currentProfile" = "0" ]; then
	profile="default";
	setDefaultProfile;

elif [ "$currentProfile" = "1" ]; then
	profile="power saving";
	setPowerSavingProfile;

elif [ "$currentProfile" = "2" ]; then
	profile="balanced";
	setBalancedProfile;

elif [ "$currentProfile" = "3" ]; then
	profile="performance";
	setPerformanceProfile;
else
	profile="default";
	setDefaultProfile;
fi
sendToLog "Current profile is $profile";

sendToLog "Applying $profile profile";
sendToLog "$divider";

# Time in seconds when starting with profile applying
# This will be later used for the time difference
start=$($BUSYBOX date +%s)

if [ "$($BUSYBOX cat "$USER_PROFILE"/battery_improvements)" -eq 1 ]; then
	batteryImprovements;
fi

if [ "$($BUSYBOX cat "$USER_PROFILE"/doze_optimization)" -eq 1 ]; then
	dozeOptimization 1;
elif [ "$($BUSYBOX cat "$USER_PROFILE"/doze_optimization)" -eq 0 ]; then
	dozeOptimization 0;
fi

#
# CPU tuner section
#
if [ "$($BUSYBOX cat "$USER_PROFILE"/cpu_optimization)" -eq 1 ]; then
	cpuOptimizationBattery;
elif [ "$($BUSYBOX cat "$USER_PROFILE"/cpu_optimization)" -eq 2 ]; then
	cpuOptimizationBalanced;
elif [ "$($BUSYBOX cat "$USER_PROFILE"/cpu_optimization)" -eq 3 ]; then
	cpuOptimizationPerformance;
fi

if [ "$($BUSYBOX cat "$USER_PROFILE"/governor_tuner)" -eq 1 ]; then
	governorTuner 1
elif [ "$($BUSYBOX cat "$USER_PROFILE"/governor_tuner)" -eq 2 ]; then
	governorTuner 2
elif [ "$($BUSYBOX cat "$USER_PROFILE"/governor_tuner)" -eq 3 ]; then
	governorTuner 3
fi

#
# Entropy section
#
if [ "$($BUSYBOX cat "$USER_PROFILE"/entropy)" -eq 1 ]; then
	entropy 1;
elif [ "$($BUSYBOX cat "$USER_PROFILE"/entropy)" -eq 2 ]; then
	entropy 2;
elif [ "$($BUSYBOX cat "$USER_PROFILE"/entropy)" -eq 3 ]; then
	entropy 3;
elif [ "$($BUSYBOX cat "$USER_PROFILE"/entropy)" -eq 4 ]; then
	entropy 4;
fi

#
# GPU section
#
if [ "$($BUSYBOX cat "$USER_PROFILE"/gpu_optimizer)" -eq 1 ]; then
	gpuOptimizer 1;
elif [ "$($BUSYBOX cat "$USER_PROFILE"/gpu_optimizer)" -eq 2 ]; then
	gpuOptimizer 2;
elif [ "$($BUSYBOX cat "$USER_PROFILE"/gpu_optimizer)" -eq 3 ]; then
	gpuOptimizer 3;
fi

if [ "$($BUSYBOX cat "$USER_PROFILE"/optimize_buffers)" -eq 1 ]; then
	optimizeBuffers;
fi

if [ "$($BUSYBOX cat "$USER_PROFILE"/render_opengles_using_gpu)" -eq 1 ]; then
	renderOpenglesUsingGpu;
fi

if [ "$($BUSYBOX cat "$USER_PROFILE"/use_opengl_skia)" -eq 1 ]; then
	useOpenglSkia;
fi

#
# I/O tweaks section
#
if [ "$($BUSYBOX cat "$USER_PROFILE"/disable_io_stats)" -eq 0 ]; then
	enableIoStats;
elif [ "$($BUSYBOX cat "$USER_PROFILE"/disable_io_stats)" -eq 1 ]; then
	disableIoStats;
fi

if [ "$($BUSYBOX cat "$USER_PROFILE"/io_blocks_optimization)" -eq 1 ]; then
	ioBlocksOptimization 1;
elif [ "$($BUSYBOX cat "$USER_PROFILE"/io_blocks_optimization)" -eq 2 ]; then
	ioBlocksOptimization 2;
elif [ "$($BUSYBOX cat "$USER_PROFILE"/io_blocks_optimization)" -eq 3 ]; then
	ioBlocksOptimization 3;
fi

if [ "$($BUSYBOX cat "$USER_PROFILE"/io_extended_queue)" -eq 1 ]; then
	ioExtendedQueue;
fi

if [ "$($BUSYBOX cat "$USER_PROFILE"/scheduler_tuner)" -eq 1 ]; then
	schedulerTuner;
fi

#
# LNET tweaks section
#
if [ "$($BUSYBOX cat "$USER_PROFILE"/dns)" -eq 1 ]; then
	dnsGooglePublic;
elif [ "$($BUSYBOX cat "$USER_PROFILE"/dns)" -eq 2 ]; then
	dnsCloudFlare;
elif [ "$($BUSYBOX cat "$USER_PROFILE"/dns)" -eq 2 ]; then
	dnsOpenDNS;
fi

if [ "$($BUSYBOX cat "$USER_PROFILE"/net_buffers)" -eq 1 ]; then
	netBuffersSmall;
elif [ "$($BUSYBOX cat "$USER_PROFILE"/net_buffers)" -eq 2 ]; then
	netBuffersBig;
fi

if [ "$($BUSYBOX cat "$USER_PROFILE"/net_speed_plus)" -eq 1 ]; then
	netSpeedPlus;
fi

if [ "$($BUSYBOX cat "$USER_PROFILE"/net_tcp)" -eq 1 ]; then
	netTcpTweaks;
fi

if [ "$($BUSYBOX cat "$USER_PROFILE"/optimize_ril)" -eq 1 ]; then
	rilTweaks;
fi

#
# Misc
#
if [ "$($BUSYBOX cat "$USER_PROFILE"/disable_debugging)" -eq 1 ]; then
	disableDebugging;
fi

if [ "$($BUSYBOX cat "$USER_PROFILE"/disable_kernel_panic)" -eq 1 ]; then
	disableKernelPanic;
fi

if [ "$($BUSYBOX cat "$USER_PROFILE"/selinux)" -eq 0 ]; then
	selinux 0;
elif [ "$($BUSYBOX cat "$USER_PROFILE"/selinux)" -eq 1 ]; then
	selinux 1;
fi

#
# RAM manager section
#
if [ "$($BUSYBOX cat "$USER_PROFILE"/ram_manager)" -eq 1 ]; then
	ramManagerMultitasking;
elif [ "$($BUSYBOX cat "$USER_PROFILE"/ram_manager)" -eq 2 ]; then
	ramManagerBalanced;
elif [ "$($BUSYBOX cat "$USER_PROFILE"/ram_manager)" -eq 3 ]; then
	ramManagerGaming;
fi

if [ "$($BUSYBOX cat "$USER_PROFILE"/disable_multitasking_limitations)" -eq 1 ]; then
	disableMultitaskingLimitations;
fi

if [ "$($BUSYBOX cat "$USER_PROFILE"/low_ram_flag)" -eq 0 ]; then
	lowRamFlagDisabled;
elif [ "$($BUSYBOX cat "$USER_PROFILE"/low_ram_flag)" -eq 1 ]; then
	lowRamFlagEnabled;
fi

if [ "$($BUSYBOX cat "$USER_PROFILE"/oom_killer)" -eq 0 ]; then
	oomKillerDisabled;
elif [ "$($BUSYBOX cat "$USER_PROFILE"/oom_killer)" -eq 1 ]; then
	oomKillerEnabled;
fi

if [ "$($BUSYBOX cat "$USER_PROFILE"/swappiness)" -eq 1 ]; then
	swappinessTendency 1;
elif [ "$($BUSYBOX cat "$USER_PROFILE"/swappiness)" -eq 2 ]; then
	swappinessTendency 2;
elif [ "$($BUSYBOX cat "$USER_PROFILE"/swappiness)" -eq 3 ]; then
	swappinessTendency 3;
elif [ "$($BUSYBOX cat "$USER_PROFILE"/swappiness)" -eq 4 ]; then
	swappinessTendency 4;
elif [ "$($BUSYBOX cat "$USER_PROFILE"/swappiness)" -eq 5 ]; then
	swappinessTendency 5;
elif [ "$($BUSYBOX cat "$USER_PROFILE"/swappiness)" -eq 6 ]; then
	swappinessTendency 6;
fi

if [ "$($BUSYBOX cat "$USER_PROFILE"/virtual_memory)" -eq 1 ]; then
	virtualMemoryTweaks 1;
elif [ "$($BUSYBOX cat "$USER_PROFILE"/virtual_memory)" -eq 2 ]; then
	virtualMemoryTweaks 2;
elif [ "$($BUSYBOX cat "$USER_PROFILE"/virtual_memory)" -eq 3 ]; then
	virtualMemoryTweaks 3;
fi

if [ "$($BUSYBOX cat "$USER_PROFILE"/heap_optimization)" -eq 1 ]; then
	heapOptimization;
fi

# End time of the script
end=$($BUSYBOX date +%s)

# Calculate how much took to set up L Speed parameters,
# everything is calculated in seconds
runtime=$((end-start))

sendToLog "Applying took $runtime seconds";
sendToLog "Successfully applied $profile profile";
sendToLog "$divider";

exit 0
fi

exit 0
